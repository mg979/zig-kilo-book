<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build your own text editor in Zig</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/css/code-blocks.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own text editor in Zig</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Some years ago a booklet has been published, called <a href="https://viewsourcecode.org/snaptoken/kilo/index.html">Build your own text
editor</a>, a guide to
create a minimal text editor from scratch in the C programming language, based
on the code of the <a href="https://github.com/antirez/kilo">kilo editor</a>. It's a fun
exercise to learn some C programming, because writing a toy text editor is fun.</p>
<p>In my attempt at learning the Zig programming language, I thought that
rewriting that editor in Zig would have been a good exercise as well, and since
learning resources for Zig aren't overly abundant, I thought it would have been
a good idea to write a guide on how to do it, step by step, following the
example of the booklet I mentioned before.</p>
<p>I want to make it clear that I'm neither an expert Zig programmer (this was my
first Zig program), or an expert programmer in general (I'm self-taught and
I just dabble with programming so to speak), so don't expect great technical
insights or elaborate programming techniques, it's not the purpose of this
document anyway. Moreover, I never claim that the way I solve a particular
problem in this program is the best way to solve it, neither that it's the one
that is the most idiomatic to the Zig programming language. Like its own
predecessor, the C programming language, Zig is rather free-form in the sense
that it doesn't enforce a particular programming style or paradigm. Still, also
Zig has its idioms and best practices, and I try to follow them in general, but
sometimes I will also show different ways to approach the same problem.</p>
<p>As a matter of fact, in this guide I don't strive to find the optimal
solutions, from the point of view of performance optimizations and memory usage
for example, but generally the simplest ones that I consider still acceptable.
It is a <em>minimal</em> text editor, after all.</p>
<p>Also remember that the program we're creating is just a toy, an exercise to
learn something more about a programming language, and not a tool that can have
any serious use.</p>
<p>Compared to the original C version, here we will not respect the 1024 lines of
code limit (from which the name <code>kilo</code> stems) and we will not be limited to
a single file, since pursuing (or even worse <em>achieving</em>) such coinciseness
would preclude us from using many useful features of the Zig programming
language, such as importable modules and instantiable types. Having everything
in a single file might make sense for small libraries, but it's not what we're
doing here.</p>
<p>I do sometimes use collapsible notes:</p>
<details id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<summary class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="introduction.html#admonition-note"></a>
</summary>
<div>
<p>Heya!</p>
</div>
</details>
<p>Speaking of the knowledge required to understand this booklet, this is not
a programming guide but rather an exercise, so I will expect that you have at
least some notion in systems programming languages like C, in the sense that
I will suppose that you know already what pointers are and how to use them, or
anything that can be considered basic programming knowledge.</p>
<p>I will also expect that you know the basics of the Zig programming language, so
if you didn't already, I suggest that you go through the exercises from the
<a href="https://codeberg.org/ziglings/exercises/#ziglings">ziglings</a> project before
attempting this one. Other learning resources that I found useful are (in no
particular order):</p>
<ul>
<li><a href="https://exercism.org/tracks/zig">Zig on exercism.org</a></li>
<li><a href="https://www.openmymind.net/learning_zig/">Learning Zig</a></li>
<li><a href="https://cookbook.ziglang.cc/intro.html">Zig Cookbook</a></li>
<li><a href="https://zig.guide/">zig.guide</a> (slightly outdated)</li>
</ul>
<p>and the most important of all, always up to date:</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/">The official Zig language
reference</a></li>
<li><a href="https://ziglang.org/documentation/master/std/">The std library documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This program was written in a Linux environment, for the Linux environment.
Therefore if you use Windows you should install WSL2 and a Linux distribution
(I tested it on Ubuntu Preview). I don't think it can work on MacOS, but you're
free to try, and anyway it would not be too difficult to make it work there in
the future.</p>
<h2 id="install-zig"><a class="header" href="#install-zig">Install zig</a></h2>
<p>First thing, you need Zig itself. If you don't have it, or if you have
a different version installed, you can download it
<a href="https://ziglang.org/download/">here</a>. Currently this document uses the <code>0.15.1</code> release, so it's the one
that you should download.</p>
<p>Decompress the archive somewhere, for example in <code>~/.local/zig</code>:</p>
<pre><code>tar xf &lt;archive&gt; --directory=/home/username/.local
mv &lt;name-of-extracted-directory&gt; zig
</code></pre>
<p>Then add this directory to your path by adding this to your <code>.bashrc</code></p>
<pre><code>export PATH=$PATH:~/.local/zig
</code></pre>
<p>Now start a new terminal instance and see if <code>zig</code> is in your path:</p>
<pre><code>zig version
</code></pre>
<p>And it should print</p>
<pre><code>0.15.1
</code></pre>
<p>Finally, choose a directory for your project and initialize it:</p>
<pre><code>mkdir kilo-zig
cd kilo-zig
zig init
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-an-editor"><a class="header" href="#setup-an-editor">Setup an editor</a></h1>
<p>You will also need a text editor, before you can use your own. Which you
shouldn't do anyway, so you need an editor.</p>
<p>I recommend you don't use any advanced tooling, like
<a href="https://github.com/zigtools/zls">zls</a>. I think that while still learning it's
better not to use them, I find it's enough to rely on what the compiler tells
you, then find and fix the mistakes by yourself.</p>
<h2 id="ctags"><a class="header" href="#ctags">ctags</a></h2>
<p>Instead, if you use an editor that supports tags, I think it's a good idea to
use them, to navigate faster between functions, types and other parts of our
project. To use tags you must have <code>universal-ctags</code> installed, for example in
Debian/Ubuntu you install it with:</p>
<pre><code>sudo apt install universal-ctags
</code></pre>
<p>But <code>ctags</code> doesn't support natively Zig, so you should create a file at
<code>~/.config/ctags/zig.ctags</code> with this content:</p>
<pre><code class="language-ctags">--langdef=zig
--map-zig=.zig

--kinddef-zig=f,function,functions
--kinddef-zig=m,method,methods
--kinddef-zig=t,type,types
--kinddef-zig=v,field,fields

# functions
--regex-zig=/^(export +)?(pub +)?(inline +)?(extern .+ )?fn +([a-zA-Z0-9_]+)/\5/f/{exclusive}

# structs, union, enum
--regex-zig=/^(export +)?(pub +)?[\t ]*const +([a-zA-Z0-9_]+) = (struct|enum|union)/\3/t/{exclusive}{scope=push}
--regex-zig=/^}///{exclusive}{scope=pop}{placeholder}

# methods
--regex-zig=/^[\t ]+(pub +)?(inline +)?fn +([a-zA-Z0-9_]+)/\3/m/{exclusive}{scope=ref}

# public constants/variables
--regex-zig=/^(export +)?pub +(const|var) +([a-zA-Z0-9_]+)(:.*)? = .*/\3/v/{exclusive}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-zig-build-system"><a class="header" href="#the-zig-build-system">The Zig build system</a></h1>
<p>From now on, I'll assume the directory of the project is located in
<code>~/kilo-zig</code>.</p>
<pre><code>cd ~/kilo-zig
</code></pre>
<p>After having initialized the project with <code>zig init</code> inside that directory,
a bunch of files will have been created. We don't need the <code>src/root.zig</code> file,
because that is only useful if we are creating a library, and we're not, so we
delete it:</p>
<pre><code>rm src/root.zig
</code></pre>
<p>We'll also have to edit the <code>build.zig</code> file, which is the zig equivalent of
a Makefile. I will not go into details about how the zig build system works,
because I barely know it myself. What matters now is that currently the default
build file is unsuitable to build our project. If we open it, we'll see that it
does several things:</p>
<ul>
<li>it defines build options</li>
<li>it defines a module (<code>mod</code> that points at <code>src/root.zig</code>)</li>
<li>it defines a main executable (<code>exe</code> that points at <code>src/main.zig</code>)</li>
<li>it adds steps for tests for both main executable and module</li>
</ul>
<p>We'll have to remove all the steps that would build a module. So you remove:</p>
<ul>
<li>the <code>mod</code> variable</li>
<li>the <code>.imports</code> field in the <code>.addExecutable()</code> argument</li>
<li>other lines with <code>mod</code>: <code>mod_tests</code>, <code>run_mod_tests</code> and so on</li>
</ul>
<p>You'll also rename <code>exe.name</code> to <code>kilo</code>.</p>
<p>This is the final <code>build.zig</code> with most comments removed:</p>
<div class="code-title">build.zig</div>
<pre><code class="language-zig">const std = @import("std");

pub fn build(b: *std.Build) void {
    // Standard target options allow the person running `zig build` to choose
    // what target to build for.
    const target = b.standardTargetOptions(.{});
    // Standard optimization options allow the person running `zig build` to select
    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.
    const optimize = b.standardOptimizeOption(.{});

    // Here we define an executable. An executable needs to have a root module
    // which needs to expose a `main` function.
    const exe = b.addExecutable(.{
        .name = "kilo",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/main.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    // By default the install prefix is `zig-out/` but can be overridden by
    // passing `--prefix` or `-p`.
    b.installArtifact(exe);

    // This creates a top level step. Top level steps have a name and can be
    // invoked by name when running `zig build` (e.g. `zig build run`).
    // This will evaluate the `run` step rather than the default step.
    const run_step = b.step("run", "Run the app");

    // This creates a RunArtifact step in the build graph.
    const run_cmd = b.addRunArtifact(exe);
    run_step.dependOn(&amp;run_cmd.step);

    // By making the run step depend on the default step, it will be run from the
    // installation directory rather than directly from within the cache directory.
    run_cmd.step.dependOn(b.getInstallStep());

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    // Creates an executable that will run `test` blocks from the executable's
    // root module.
    const exe_tests = b.addTest(.{
        .root_module = exe.root_module,
    });

    // A run step that will run the second test executable.
    const run_exe_tests = b.addRunArtifact(exe_tests);

    // A top level step for running all tests.
    const test_step = b.step("test", "Run tests");
    test_step.dependOn(&amp;run_exe_tests.step);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-mainzig-file"><a class="header" href="#the-mainzig-file">The main.zig file</a></h1>
<p>Every respectable program has an entry point, to let users to actually execute
it and do something with it. Our program is no exception.</p>
<p>Our entry point is located in <code>src/main.zig</code>, as we defined it in the
<code>build.zig</code> script. The file doesn't have to be named this way, but it must
contain a <code>main()</code> function.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="main/main.html#admonition-note"></a>
</div>
<div>
<p>I like to have big banners to separate sections of the source code, you don't
have to follow my habits of course, feel free to remove them if you don't like
them.</p>
</div>
</div>
<p><code>zig init</code> created a <code>src/main.zig</code>, which we'll have to replace entirely with
this:</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Main function
//
///////////////////////////////////////////////////////////////////////////////

pub fn main() !void {
    var da = std.heap.DebugAllocator(.{}){};
    defer _ = da.deinit();

    const allocator = switch (builtin.mode) {
        .Debug =&gt; da.allocator(),
        else =&gt; std.heap.smp_allocator,
    };
    _ = allocator;
}

///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const builtin = @import("builtin");
</code></pre>
<p>We keep the constants at the bottom of the file, so they don't get too much in
the way. Now they're two, but there's often a whole lot of them.</p>
<p>What we're doing for now is define the allocators we'll be using. Code doesn't
compile if the variables defined in it aren't being used, Zig never likes that.
So for now we have:</p>
<pre><code>_ = allocator;
</code></pre>
<p>after we define the constant.</p>
<p>What this code means, at any rate, is that we use the debug allocator in Debug
mode, and a much faster allocator in proper release modes.</p>
<p>The <code>builtin.mode</code> defaults to <code>.Debug</code>, so if we simply run</p>
<pre><code>zig build
</code></pre>
<p>it will build the program in debug mode. To use the faster allocator we'll need
to pass an argument, for example:</p>
<pre><code>zig build -Doptimize=ReleaseSmall # optimize for small binary size
zig build -Doptimize=ReleaseFast # optimize for performance
zig build -Doptimize=ReleaseSafe # optimize for safety
</code></pre>
<p>But we'll mostly build in debug mode, because if something goes wrong and the
program panics, we'll get the most useful informations about what has caused
the panic, such as array access with index out of bounds (it happened often to
me while writing the program).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-handler"><a class="header" href="#panic-handler">Panic handler</a></h1>
<p>Speaking of panic, we want to add our own panic handler. Normally, if the
program panics, it will crash and invoke the default panic handler, which
prints a stack trace about the error. We'll need more than that, so we change
the panic handler to our own:</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Panic handler
//
///////////////////////////////////////////////////////////////////////////////

pub const panic = std.debug.FullPanic(crashed);

fn crashed(msg: []const u8, trace: ?usize) noreturn {
    std.debug.defaultPanic(msg, trace);
}
</code></pre>
<p>Since we don't need it for anything yet, what it does is simply to call the
default panic handler, passing the same arguments it receives.</p>
<p>You may have noticed that strange return type: <code>noreturn</code>. It means the
function doesn't simply return anything, like a <code>void</code> would do, it doesn't
return at all. This is so because when this function is called, our program has
crashed already, and it couldn't return any value anyway. You shouldn't worry
about it because it's the first and last time we'll see it in our program.</p>
<div id="admonition-whats-panic-anyway" class="admonition admonish-note" role="note" aria-labelledby="admonition-whats-panic-anyway-title">
<div class="admonition-title">
<div id="admonition-whats-panic-anyway-title">
<p>What's panic anyway?</p>
</div>
<a class="admonition-anchor-link" href="main/panic.html#admonition-whats-panic-anyway"></a>
</div>
<div>
<p>When the program encounters an error at runtime, depending on the kind of
error, two things may happen:</p>
<ul>
<li>the program crashes (best case)</li>
<li>the program keeps running, but its state is corrupted (worst case)</li>
</ul>
<p>In the second case really nasty things can happen, so we want to avoid bugs at
all costs. In <em>safe</em> release modes (Debug and ReleaseSafe), events that would
normally cause a crash or undefined behavior cause <em>panic</em> instead. The program
terminates and you get a meaningful stack trace of what has caused the error.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-configuration"><a class="header" href="#terminal-configuration">Terminal configuration</a></h1>
<p>When we write text in an editor, the character is immediately read and handled
by the program. This is not what happens normally in a terminal, because the
default way a terminal handles keypresses is the so-called <strong>canonical
mode</strong>: in this mode, keys are sent to the program only after the user presses
the <kbd>Enter</kbd> key.</p>
<p>Let's write first a function that can read bytes from the user keypresses:</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">// Read from stdin into `buf`, return the number of read characters
fn readChar(buf: []u8) !usize {
    const stdin = std.posix.STDIN_FILENO;
    return try std.posix.read(stdin, buf);
}
</code></pre>
<p>This will read from <code>stdin</code> one character at a time, store the read character
in <code>buf</code> and return the number of characters that have been read.
<code>buf</code> should be a slice, because <code>std.posix.read</code> accepts a slice as parameter.</p>
<p>In general, you'll find out that working with slices will prevent a lot of
headaches, because the Zig type system is very strict, but most functions of
the standard libraries that work with arrays are designed to take a slice as
parameter. You still keep the ownership of the underlying array, of course.</p>
<p>Remeber that to pass a slice of an array to a function we use one of the
following notations:</p>
<pre><code class="language-zig">    &amp;array      // create the slice by taking the address of an array
    array[0..]  // a slice with all elements of an array
</code></pre>
<p>Let's call it from <code>main()</code> by adding these lines:</p>
<div class="code-diff-added">
<pre><code class="language-zig">    };
    _ = allocator;
</code></pre>
</div>
<pre><code class="language-zig">    var buf: [1]u8 = undefined;
    while (try readChar(&amp;buf) == 1 and buf[0] != 'q') {}
</code></pre>
<p>If you build and run the program in a terminal, you'll see that even if you
press <kbd>q</kbd> the loop doesn't stop, you need to press <kbd>Enter</kbd>,
and if you press any key after <kbd>q</kbd>, you'll find those characters in
your command line prompt.</p>
<p>So you'll understand the need to change how the terminal sends what it reads to
our program, and this is what <strong>raw mode</strong> is for.</p>
<p>For this purpose, we'll create a new module for our program, we'll call it
<code>linux</code>, and it will handle all interactions with the operating system, such as
reading characters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-linux-module"><a class="header" href="#the-linux-module">The linux module</a></h1>
<p>Create a file <code>src/linux.zig</code> and paste the following content:</p>
<div class="code-title">linux.md</div>
<pre><code class="language-zig">//! Module that handles interactions with the operating system.

///////////////////////////////////////////////////////////////////////////////
//
//                              Raw mode
//
///////////////////////////////////////////////////////////////////////////////

/// Enable terminal raw mode, return previous configuration.
pub fn enableRawMode() !linux.termios {
    const orig_termios = try posix.tcgetattr(STDIN_FILENO);

    // stuff here

    return orig_termios;
}

/// Disable terminal raw mode by restoring the saved configuration.
pub fn disableRawMode(termios: linux.termios) void {
    posix.tcsetattr(STDIN_FILENO, .FLUSH, termios) catch @panic("Disabling raw mode failed!");
}

///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const linux = std.os.linux;
const posix = std.posix;

const STDOUT_FILENO = posix.STDOUT_FILENO;
const STDIN_FILENO = posix.STDIN_FILENO;
</code></pre>
<p>For now, we have two functions:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>enableRawMode</strong></td><td>should change the terminal configuration, switching away from canonical mode, then should return the original configuration</td></tr>
<tr><td><strong>disableRawMode</strong></td><td>should restore the original configuration</td></tr>
</tbody></table>
</div>
<p>We have to fill the <code>enableRawMode</code> function, since right now it's not doing
anything.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enabling-raw-mode"><a class="header" href="#enabling-raw-mode">Enabling raw mode</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="terminal/raw_mode.html#admonition-note"></a>
</div>
<div>
<p>The original booklet I mentioned in the introduction goes into <a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">great
detail</a> in
explaining what all the flags mean. I have no intention to do that, if you are
curious about them you can consult the original.</p>
</div>
</div>
<p>First we make a copy of the original configuration, so that we can modify it.</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    // stuff here
</code></pre>
</div>
<pre><code class="language-zig">    // make a copy
    var termios = orig_termios;
</code></pre>
<p>We then set a number of flags in this copy. We disable echoing of the
characters we type:</p>
<pre><code class="language-zig">    termios.lflag.ECHO = false; // don't echo input characters
</code></pre>
<p>We disable canonical mode, so that the terminal doesn't wait for
<kbd>Enter</kbd> to be pressed when reading characters:</p>
<pre><code class="language-zig">    termios.lflag.ICANON = false; // read input byte-by-byte instead of line-by-line
</code></pre>
<p>We disable some key combinations that usually have a special behavior in
terminals, so that are available for us to use them in our program:</p>
<pre><code class="language-zig">    termios.lflag.ISIG = false; // disable Ctrl-C and Ctrl-Z signals
    termios.iflag.IXON = false; // disable Ctrl-S and Ctrl-Q signals
    termios.lflag.IEXTEN = false; // disable Ctrl-V
    termios.iflag.ICRNL = false; // CTRL-M being read as CTRL-J
</code></pre>
<p>For reference:</p>
<div class="table-wrapper"><table><thead><tr><th>key</th><th>default behavior</th></tr></thead><tbody>
<tr><td><kbd>Ctrl-C</kbd></td><td>sends a <code>SIGINT</code> signal that causes the program to terminate</td></tr>
<tr><td><kbd>Ctrl-Z</kbd></td><td>sends a <code>SIGSTOP</code> signal which causes the suspension of the program (which you can then resume with <code>fg</code> in the terminal command line)</td></tr>
<tr><td><kbd>Ctrl-S</kbd></td><td>produces <code>XOFF</code> control character, halts data transmission</td></tr>
<tr><td><kbd>Ctrl-Q</kbd></td><td>produces <code>XON</code> control character, resumes data transmission</td></tr>
<tr><td><kbd>Ctrl-V</kbd></td><td>next character will be inserted literally</td></tr>
<tr><td><kbd>Ctrl-M</kbd></td><td>read as ASCII <code>10</code> <kbd>Ctrl-J</kbd> instead of <code>13</code> <kbd>Enter</kbd></td></tr>
</tbody></table>
</div>
<p>Let's disable output processing, to prevent the terminal to issue a carriage
return (<code>\r</code>) in addition to each new line (<code>\n</code>) when <kbd>Enter</kbd> is
pressed:</p>
<pre><code class="language-zig">    termios.oflag.OPOST = false; // disable output processing
</code></pre>
<p>You can see that the termios flags are placed into structs that start either
with <code>i</code> (input, as in <code>iflags</code>) or <code>o</code> (output, as in <code>oflags</code>).</p>
<p>Let's disable more flags, which are even more obscure than the previous ones
and that I won't even try to explain (sorry):</p>
<pre><code class="language-zig">    termios.iflag.BRKINT = false; // break conditions cause SIGINT signal
    termios.iflag.INPCK = false; // disable parity checking (obsolete?)
    termios.iflag.ISTRIP = false; // disable stripping of 8th bit
    termios.cflag.CSIZE = .CS8; // set character size to 8 bits
</code></pre>
<details id="admonition-from-the-original-booklet" class="admonition admonish-quote" role="note" aria-labelledby="admonition-from-the-original-booklet-title">
<summary class="admonition-title">
<div id="admonition-from-the-original-booklet-title">
<p>From the original booklet</p>
</div>
<a class="admonition-anchor-link" href="terminal/raw_mode.html#admonition-from-the-original-booklet"></a>
</summary>
<div>
<p>This step probably won’t have any observable effect for you, because these
flags are either already turned off, or they don’t really apply to modern
terminal emulators. But at one time or another, switching them off was
considered (by someone) to be part of enabling “raw mode”, so we carry on the
tradition (of whoever that someone was) in our program.</p>
<p>As far as I can tell:</p>
<ul>
<li>When BRKINT is turned on, a break condition will cause a SIGINT signal to
be sent to the program, like pressing Ctrl-C.</li>
<li>INPCK enables parity checking, which doesn’t seem to apply to modern
terminal emulators.</li>
<li>ISTRIP causes the 8th bit of each input byte to be stripped, meaning it
will set it to 0. This is probably already turned off.</li>
<li>CS8 is not a flag, it is a bit mask with multiple bits, which we set
using the bitwise-OR (|) operator unlike all the flags we are turning
off. It sets the character size (CS) to 8 bits per byte. On my system,
it’s already set that way.</li>
</ul>
</div>
</details>
<h2 id="a-timeout-for-read"><a class="header" href="#a-timeout-for-read">A timeout for <code>read()</code></a></h2>
<p>Finally, we want to set a timeout for <code>read()</code>, so that our editor will be able
to discern an <kbd>Esc</kbd> from an escape sequence. In fact, all terminal
escape sequences that codify for many keys begin with an <kbd>Esc</kbd> (that's
why they are called <em>escape sequences</em>), and we want to be able to handle them
accordingly.</p>
<p>Here we use some constants that are defined in <code>std.os.linux</code>. Since they are
in an <code>enum</code>, we'll have to use the builtin function <code>@intFromEnum()</code> so that
we can use them for array indexing (which expects an <code>usize</code> type).</p>
<pre><code class="language-zig">    // Set read timeouts
    termios.cc[@intFromEnum(linux.V.MIN)] = 0; // Return immediately when any bytes are available
    termios.cc[@intFromEnum(linux.V.TIME)] = 1; // Wait up to 0.1 seconds for input
</code></pre>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="terminal/raw_mode.html#admonition-important"></a>
</div>
<div>
<p>This took me hours to figure out. The original kilo editor uses constants that
come from the <em>libc</em> <code>termios.h</code> header, but initially I simply used the values
from the C version, thinking they would apply also for the Zig version. They
didn't work, that is, there was no read timeout. I initially asked the AI, and
it didn't help. I then looked for other Zig implementations of this same editor
on the internet, but all of them repeated this mistake, until I found one
implementation that did the right thing, that is, to use the constants that are
provided by the Zig standard library (what is being done in the snippet of code
above).</p>
<p>The lesson was: don't try to reinvent a system-defined constant, use the
system-defined constant, even if it means that you must look for it in the
standard library.</p>
</div>
</div>
<p>We're done, we can apply the new terminal configuration and return the original
one:</p>
<div class="code-diff-added-top">
<pre><code class="language-zig">    // update config
    try posix.tcsetattr(STDIN_FILENO, .FLUSH, termios);
</code></pre>
</div>
<pre><code class="language-zig">    return orig_termios;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="back-to-mainzig"><a class="header" href="#back-to-mainzig">Back to main.zig</a></h1>
<p>We left our main function in this state:</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">pub fn main() !void {
    var da = std.heap.DebugAllocator(.{}){};
    defer _ = da.deinit();

    const allocator = switch (builtin.mode) {
        .Debug =&gt; da.allocator(),
        else =&gt; std.heap.smp_allocator,
    };
    _ = allocator;

    var buf: [1]u8 = undefined;
    while (try readChar(&amp;buf) == 1 and buf[0] != 'q') {}
}
</code></pre>
<p>Now we want to enable raw mode, right? And it's the first thing that our main
function will do. Add these lines at the top of it:</p>
<div class="code-diff-added">
<pre><code class="language-zig">pub fn main() !void {
</code></pre>
</div>
<pre><code class="language-zig">    orig_termios = try linux.enableRawMode();
    defer linux.disableRawMode(orig_termios);
</code></pre>
<p>The <code>defer</code> statement is important because we want to restore the original
configuration when the program exits. We also want to update the bottom section
with our new variables. Add this at the bottom of the file:</p>
<pre><code class="language-zig">const linux = @import("linux.zig");

var orig_termios: std.os.linux.termios = undefined;
</code></pre>
<div id="admonition-reminder" class="admonition admonish-tip" role="note" aria-labelledby="admonition-reminder-title">
<div class="admonition-title">
<div id="admonition-reminder-title">
<p>Reminder</p>
</div>
<a class="admonition-anchor-link" href="terminal/main_raw_mode.html#admonition-reminder"></a>
</div>
<div>
<p>When variables and constants are placed at the root level of a file, that is,
outside any functions, they behave like <code>static</code> identifiers in C, only visible
to the code of the current file, unless they have the <code>pub</code> qualifier, meaning
they can be accessed from files that import the current one.</p>
<p>Moreover, if the module is meant to be instantiated (it has fields defined at
the root level), these variable and constants are, again, static, not part of
the instances: all instances will share the same value, which is quite obvious
for constants, less so for variables.</p>
</div>
</div>
<p>Why is it important to define <code>orig_termios</code> at the root level? Because we want
to handle another case: our program crashes, and we don't want to leave the
terminal in an unusable state if that happens. We'll have to update our crash
handler as well:</p>
<div class="code-diff-added">
<pre><code class="language-zig">/// Our panic handler disables terminal raw mode and calls the default panic
/// handler.
fn crashed(msg: []const u8, trace: ?usize) noreturn {
</code></pre>
</div>
<pre><code class="language-zig">    linux.disableRawMode(orig_termios);
</code></pre>
<p>As you can see, also this function needs to access the original terminal
configuration, and there's no way to pass it with an argument, it must read it
from a variable.</p>
<p>Now, if you try to build and run the project, something strange happens: the
program terminates immediately.</p>
<details id="admonition-can-you-guess-why" class="admonition admonish-note" role="note" aria-labelledby="admonition-can-you-guess-why-title">
<summary class="admonition-title">
<div id="admonition-can-you-guess-why-title">
<p>Can you guess why?</p>
</div>
<a class="admonition-anchor-link" href="terminal/main_raw_mode.html#admonition-can-you-guess-why"></a>
</summary>
<div>
<p>Because of the timeout to <code>read()</code> in <code>enableRawMode()</code>. If you comment out the
two lines where the timeout is set, you can recompile, run, and see that the
prompt keeps reading characters until you press <kbd>q</kbd>, only then it
terminates.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-the-window-size"><a class="header" href="#getting-the-window-size">Getting the window size</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="screensize/window_size_intro.html#admonition-note"></a>
</div>
<div>
<p>Before we proceed, delete the last 2 lines in the main functions (the ones that
read the from input) and the <code>readChar()</code> function as well, we won't need them
anymore.</p>
</div>
</div>
<p>We went past raw mode, which was possibly annoying. Unfortunately we must take
care of the low level code before we can proceed to code the actual editor.
And there's still a good bit to come.</p>
<p>Before we can draw anything on the screen, we must know its size, the number of
rows and columns.</p>
<p>There are two ways to do this, with the second method that will be attempted in
the case that the first one fails.</p>
<p>The first method involves calling the linux <code>ioctl</code> function to request the
window size from the operating system.</p>
<p>The fallback method involves determining the cursor position in a maximized
window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ioctl-method"><a class="header" href="#the-ioctl-method">The <code>ioctl</code> method</a></h1>
<p>We'll first create two new modules:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>types.zig</strong></td><td>hub for all the custom types of our editor</td></tr>
<tr><td><strong>ansi.zig</strong></td><td>handles ansi escape sequences</td></tr>
</tbody></table>
</div>
<p>In <code>src/types.zig</code> we'll write this:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">//! Collection of types used by the editor.

///////////////////////////////////////////////////////////////////////////////
//
//                              Editor types
//
///////////////////////////////////////////////////////////////////////////////

/// Dimensions of the terminal screen where the editor runs.
pub const Screen = struct {
    rows: usize = 0,
    cols: usize = 0,
};
</code></pre>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="screensize/ioctl.html#admonition-important"></a>
</div>
<div>
<p>Zig supports default initializers in structs, but with some catch... more on
this later.</p>
</div>
</div>
<p>In <code>src/ansi.zig</code> we'll write this:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">//! Module that handles ansi terminal sequences.

///////////////////////////////////////////////////////////////////////////////
//
//                              Functions
//
///////////////////////////////////////////////////////////////////////////////

/// Get the window size.
pub fn getWindowSize() !t.Screen {
    // code to come...
}

///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const linux = @import("linux.zig");
const t = @import("types.zig");
</code></pre>
<p>We should fill the <code>getWindowSize()</code> function.</p>
<div class="code-title">ansi.zig: getWindowSize()</div>
<pre><code class="language-zig">    var screen: t.Screen = undefined;
    var wsz: std.posix.winsize = undefined;

    if (linux.winsize(&amp;wsz) == -1 or wsz.col == 0) {
        // fallback method will be here
    } else {
        screen = t.Screen{
            .rows = wsz.row,
            .cols = wsz.col,
        };
    }
    return screen;
</code></pre>
<p>Much like in the original C code, we use <code>ioctl()</code> to request the window size
of the terminal, and this will be stored in the <code>wsz</code> struct which we pass by
reference.</p>
<p>The <code>ioctl()</code> function returns <code>-1</code> on failure, but we consider a failure also
a column value of <code>0</code> in the passed <code>wsz</code> struct.</p>
<p>Note that in the second part of the condition (<code>wsz.col == 0</code>) <code>wsz</code> would
already have a value because it's assumed that the <code>ioctl()</code> call was
successful, since it didn't return <code>-1</code>.</p>
<h2 id="the-winsize-function"><a class="header" href="#the-winsize-function">The <code>winsize()</code> function</a></h2>
<p>We'll also have to update our <code>src/linux.zig</code> module to add the <code>winsize()</code>
function that is called in <code>getWindowSize()</code>:</p>
<div class="code-title">linux.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Functions
//
///////////////////////////////////////////////////////////////////////////////

/// Read the window size into the `wsz` struct.
pub fn winsize(wsz: *posix.winsize) usize {
    return linux.ioctl(STDOUT_FILENO, linux.T.IOCGWINSZ, @intFromPtr(wsz));
}
</code></pre>
<p>To know why <code>std.os.linux.ioctl</code> is invoked like that, we should look for it in
the Zig standard library:</p>
<div class="code-title">std/os/linux.zig</div>
<pre><code class="language-zig">pub fn ioctl(fd: fd_t, request: u32, arg: usize) usize {
    return syscall3(.ioctl, @as(usize, @bitCast(@as(isize, fd))), request, arg);
}
</code></pre>
<p>The function doesn't have any documentation, so we just invoke it like we
invoked the one in the original written in C, where the call was:</p>
<div class="code-title">C</div>
<pre><code class="language-c">    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;wsz) == -1 || wsz.ws_col == 0)
</code></pre>
<p>The <code>TIOCGWINSZ</code> is replaced by the <code>linux.T.IOCGWINSZ</code> constant, found in
<code>std.os.linux</code> module of the Zig standard library.</p>
<p>The other difference is the third argument, that is <code>usize</code> in Zig, so we must
do a pointer cast to integer:</p>
<pre><code class="language-zig">@intFromPtr(wsz)
</code></pre>
<div id="admonition-reminder" class="admonition admonish-tip" role="note" aria-labelledby="admonition-reminder-title">
<div class="admonition-title">
<div id="admonition-reminder-title">
<p>Reminder</p>
</div>
<a class="admonition-anchor-link" href="screensize/ioctl.html#admonition-reminder"></a>
</div>
<div>
<p>Remember to mark functions with the <code>pub</code> qualifier when they are called by
other modules.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="screensize/ioctl.html#admonition-note"></a>
</div>
<div>
<p>I put this function in <code>linux</code> module because I preferred to keep all the low
level interactions with the operating system in it.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-cursor-position-method"><a class="header" href="#the-cursor-position-method">The cursor position method</a></h1>
<p>In case of failure, we'll have to resort to a second method.</p>
<p>We replace the commented line in <code>getWindowSize()</code> with:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    if (linux.winsize(&amp;wsz) == -1 or wsz.col == 0) {
        // fallback method will be here
</code></pre>
</div>
<pre><code class="language-zig">    if (linux.winsize(&amp;wsz) == -1 or wsz.col == 0) {
        screen = try getCursorPosition();
</code></pre>
<p>Our <code>getCursorPosition()</code> function also goes just below <code>getWindowSize()</code>:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Get the cursor position, to determine the window size.
pub fn getCursorPosition() !t.Screen {
    // code to come...
}
</code></pre>
<p>What should we do in there? The idea is to maximize the terminal screen, so
that the cursor is positioned to the bottom-right corner, and read the current
row and column from there.</p>
<p>For both things, we need issue escape sequences to the terminal.</p>
<ul>
<li>
<p>to maximize the screen, we'll issue two sequences in a row, one to set the
columns and one to set the rows.</p>
</li>
<li>
<p>to read the cursor position, we'll issue a sequence, and read the response of
the terminal in a <code>[]u8</code> buffer</p>
</li>
</ul>
<h3 id="ansi-escape-sequences"><a class="header" href="#ansi-escape-sequences">ANSI escape sequences</a></h3>
<p>We'll define the following constants in <code>ansi.zig</code>:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Control Sequence Introducer: ESC key, followed by '[' character
pub const CSI = "\x1b[";

/// The ESC character
pub const ESC = '\x1b';

// Sets the number of column and rows to very high numbers, trying to maximize
// the window.
pub const WinMaximize = CSI ++ "999C" ++ CSI ++ "999B";

// Reports the cursor position (CPR) by transmitting ESC[n;mR, where n is the
// row and m is the column
pub const ReadCursorPos = CSI ++ "6n";
</code></pre>
<h3 id="linuxwrite"><a class="header" href="#linuxwrite"><code>linux.write()</code></a></h3>
<p>How exactly do we send these sequences? We're back into <code>linux.zig</code>.</p>
<div class="code-title">linux.zig</div>
<pre><code class="language-zig">// Write bytes to stdout, return error if the requested amount of bytes
// couldn't be written.
pub fn write(buf: []const u8) !void {
    if (try posix.write(STDOUT_FILENO, buf) != buf.len) {
        return error.WriteIncomplete;
    }
}
</code></pre>
<p><code>WriteIncomplete</code> in this case is an error I just made up, probably it's not
a very good way to handle incomplete writes, in the sense that we should
probaby retry. In my defense, I can say that the original C editor did this:</p>
<div class="code-title">C</div>
<pre><code class="language-c">  if (write(STDOUT_FILENO, "\x1b[6n", 4) != 4) return -1;
</code></pre>
<p>which means that it gave up all the same. Hey... I think we're trying hard
enough already. At least for our humble editor, that is.</p>
<h3 id="back-to-getcursorposition"><a class="header" href="#back-to-getcursorposition">Back to <code>getCursorPosition()</code></a></h3>
<p>Now it's hopefully clear what we'll do:</p>
<ol>
<li>issue sequences to maximize screen and to report cursor position</li>
<li>read the response in a <code>[]u8</code> buffer</li>
<li>parse the result, to extract the screen size</li>
</ol>
<div class="code-title">ansi.zig: getCursorPosition()</div>
<pre><code class="language-zig">    var buf: [32]u8 = undefined;

    try linux.write(WinMaximize ++ ReadCursorPos);

    var nread = try linux.readChars(&amp;buf);
</code></pre>
<p>What's that <code>readChars()</code> over there?</p>
<p>This is actually the function that we'll use to read all input from <code>stdin</code>, so
it's worth taking care of it right now. It's not too different from the
<code>readChar()</code> function we wrote in <code>main.zig</code> and that we carelessly deleted
when we didn't need it anymore.</p>
<h3 id="linuxreadchars"><a class="header" href="#linuxreadchars"><code>linux.readChars()</code></a></h3>
<div class="code-title">linux.zig</div>
<pre><code class="language-zig">/// Keep reading from stdin until we get a valid character, ignoring
/// .WouldBlock errors.
pub fn readChars(buf: []u8) !usize {
    while (true) {
        const n = posix.read(STDIN_FILENO, buf) catch |err| switch (err) {
            error.WouldBlock =&gt; continue,
            else =&gt; return err,
        };
        if (n &gt;= 1) return n;
    }
}
</code></pre>
<p>Let's compare it with the previous <code>readChar()</code> function which was:</p>
<pre><code class="language-zig">// Read from stdin into `buf`, return the number of read characters.
fn readChar(buf: []u8) !usize {
    return try posix.read(STDIN_FILENO, buf);
}
</code></pre>
<p>The main difference is that now we are in raw mode, and there is a <code>read()</code>
timeout in place, so we must handle the error which happens when the timeout
kicks in. This error is <code>.WouldBlock</code>, and we must ignore it, that is, we must
keep reading until we read something, or a different error is returned by
<code>posix.read()</code>.</p>
<p>If <code>posix.read()</code> finally returns a positive number because it read something,
we return it. If it didn't read anything, it's probably because we didn't type
anything, and the loop continues.</p>
<h3 id="back-to-getcursorposition-1"><a class="header" href="#back-to-getcursorposition-1">Back to <code>getCursorPosition()</code></a></h3>
<p>So now we got the response from the terminal, and we read it inside our <code>[]u8</code>
buffer.</p>
<div class="code-title">ansi.zig: getCursorPosition()</div>
<div class="code-diff-added">
<pre><code class="language-zig">    var nread = try linux.readChars(&amp;buf);
</code></pre>
</div>
<pre><code class="language-zig">    if (nread &lt; 5) return error.CursorError;
</code></pre>
<p>For a response to be valid, it should follow this format:</p>
<pre><code>ESC ] rows ; cols R
</code></pre>
<p>for example, <code>0x1b]50;120R</code>. This sequence has a minimum of 5 characters, plus
the final <code>R</code>. I think in some occasions I couldn't read the <code>R</code> character
immediately, but maybe I've been doing something wrong? Anyway this is what we
do:</p>
<div class="code-title">ansi.zig: getCursorPosition()</div>
<pre><code class="language-zig">    // we should ignore the final R character
    if (buf[nread - 1] == 'R') {
        nread -= 1;
    }
    // not there yet? we will ignore it, but it should be there
    else if (try linux.readChars(buf[nread..]) != 1 or buf[nread] != 'R') {
        return error.CursorError;
    }
</code></pre>
<p>That is, we keep reading until we get this <code>R</code> character, if it's not yet in
our buffer. Since we don't want to overwrite our previous response, we pass
a slice that starts at <code>nread</code>, which is the number of characters that have
been read until now. When <code>R</code> is finally read, <code>buf[nread]</code> should hold it.</p>
<p>If the first two characters aren't <code>ESC ]</code>, we error out:</p>
<div class="code-title">ansi.zig: getCursorPosition()</div>
<pre><code class="language-zig">    if (buf[0] != ESC or buf[1] != '[') return error.CursorError;
</code></pre>
<p>Finally we must parse the number of rows and columns. The original C code used
<code>sscanf()</code> for this purpose, but we won't use <code>libc</code> in this project. We parse
it by hand.</p>
<div class="code-title">ansi.zig: getCursorPosition()</div>
<pre><code class="language-zig">    var screen = t.Screen{};
    var semicolon: bool = false;
    var digits: u8 = 0;

    // no sscanf, format to read is "row;col"
    // read it right to left, so we can read number of digits
    // stop before the CSI, so at index 2
    var i = nread;
    while (i &gt; 2) {
        i -= 1;
        if (buf[i] == ';') {
            semicolon = true;
            digits = 0;
        }
        else if (semicolon) {
            screen.rows += (buf[i] - '0') * try std.math.powi(usize, 10, digits);
            digits += 1;
        } else {
            screen.cols += (buf[i] - '0') * try std.math.powi(usize, 10, digits);
            digits += 1;
        }
    }
    if (screen.cols == 0 or screen.rows == 0) {
        return error.CursorError;
    }
    return screen;
</code></pre>
<p>If you did programming exercises before, this method of parsing integers should
be familiar. The Zig standard library has a function for this purpose
(<code>std.fmt.parseInt</code>), but in this case it wouldn't have spared us much trouble.
There's a semicolon between the numbers, and we would have needed to track the
start and end position of both numbers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-test"><a class="header" href="#first-test">First test</a></h1>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="screensize/test_winsize.html#admonition-important"></a>
</div>
<div>
<p>This test will be special because it needs an interactive terminal, it will not
be executed with:</p>
<pre><code>zig build test
</code></pre>
<p>but with:</p>
<pre><code>zig test src/term_tests.zig
</code></pre>
<p>It will be the only test of this kind, unfortunately it's also the first one.</p>
</div>
</div>
<p>We want to test if our functions work. Specifically, we'll test the
<code>getWindowSize()</code> and <code>getCursorPosition()</code>, which also test setting raw mode
and <code>readChars()</code> along the way.</p>
<p>We'll add a couple of constants at the bottom of <code>ansi.zig</code>:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">const builtin = @import("builtin");

// CSI sequence to clear the screen.
pub const ClearScreen = CSI ++ "2J" ++ CSI ++ "H";
</code></pre>
<p>We'll create a new file named <code>src/term_tests.zig</code>, with this content:</p>
<div class="code-title">term_tests.zig</div>
<pre><code class="language-zig">//! Additional tests that need an interactive terminal, not testable with:
//!
//!     zig build test
//!
//! Must be tested with:
//!
//!     zig test src/term_tests.zig

test "getWindowSize" {
    const orig_termios = try linux.enableRawMode();
    defer linux.disableRawMode(orig_termios);

    const s1 = try ansi.getWindowSize();
    try std.testing.expect(s1.rows &gt; 0 and s1.cols &gt; 0);
    const s2 = try ansi.getCursorPosition();
    try linux.write(ansi.ClearScreen);
    try std.testing.expect(s1.rows == s2.rows and s1.cols == s2.cols);
}

const std = @import("std");
const linux = @import("linux.zig");
const ansi = @import("ansi.zig");
</code></pre>
<p>We'll clear the screen after having called the second method, because that
function call has the side-effect of maximizing the terminal screen, which
messes up the output of the test result.</p>
<p>To ensure that our <code>getWindowSize()</code> works and doesn't fallback, we must add
a check in that function:</p>
<div class="code-title">ansi.zig: getWindowSize()</div>
<div class="code-diff-added">
<pre><code class="language-zig">    if (linux.winsize(&amp;wsz) == -1 or wsz.col == 0) {
</code></pre>
</div>
<pre><code class="language-zig">        if (builtin.is_test) return error.getWindowSizeFailed;
</code></pre>
<p>This will cause the function to error out, if the <code>ioctl</code> method fails.
We will then get the window size with the fallback method, and ensure the
resulting sizes are the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="digression-the-comptime-keyword"><a class="header" href="#digression-the-comptime-keyword">Digression: the comptime keyword</a></h1>
<p>You probably know of <code>comptime</code> in Zig. Here we have an application of the
concept: since the <code>builtin.is_test</code> variable is evaluated at compile time, the
whole branch in <code>getWindowSize()</code> can be resolved at compile time, the relative
code will be removed and will not be executed at runtime.</p>
<p>This has the same effect of an <code>#ifdef</code> block in C for conditional compilation,
but the syntax looks much less intrusive. You can even force any expression to
be evaluated at compile time by using the <code>comptime</code> keyword before the
expression, but here it's not needed, because the <code>builtin.is_test</code> variable is
guaranteed to be compile-time known.</p>
<p>While using the <code>comptime</code> keyword, sometimes the compiler complains that using
the keyword is redundant, because the expression is always compile-time known,
other times it doesn't complain, as in the case above, even if I'm pretty sure
that all <code>builtin</code> variables are compile-time known. We saw another example in
the <code>main()</code> function, where the allocator was chosen by testing the
<code>builtin.mode</code> variable.</p>
<p>To my understanding, also from reading several posts made by the original
creator of Zig (Andrew Kelley), most of the time it's not necessary to use the
keyword, the compiler is smart enough to evaluate at compile time what it can,
even if you don't specify it expressly. But sometimes the compiler says:</p>
<pre><code>error: unable to resolve comptime value
</code></pre>
<p>In these cases the <code>comptime</code> keyword might fix the issue.</p>
<p>Bottom line: don't be compulsive in filling your code with <code>comptime</code>, it's not
necessary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-editor-types"><a class="header" href="#the-editor-types">The editor types</a></h1>
<p>Now it's time for the first steps towards the creation of our editor.</p>
<p>The original C code of <code>kilo</code> is single-file, with a global variable <code>E</code> that
holds the Editor <em>struct</em>, and all functionalities are implemented there.
Initially I wrote this program pretty much in the same way, and it worked, as
a demonstration that you can write code in Zig that uses global variables, just
as in old-fashioned C programs.</p>
<p>In Zig you can also (and probably should) use instantiable types, which then
are used in a OOP fashion by omitting the first argument when this is of the
same type, either passed by reference or by value. You should know this
already, so I won't elaborate.</p>
<p>It may be useful to remind that a Zig module is essentially a <code>struct</code>, that
is, you can think the content of a file as wrapped in</p>
<pre><code class="language-zig">struct {
    // the file content
}
</code></pre>
<p>which means that we can define at the root level of a file the members of our
type, then treat the whole file as an instantiable type. That's what we'll do
with the main types of our editor, which will be:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Editor</strong></td><td>for the editor functionalities</td></tr>
<tr><td><strong>Buffer</strong></td><td>for the file contents</td></tr>
<tr><td><strong>Row</strong></td><td>each row of the buffer</td></tr>
<tr><td><strong>View</strong></td><td>tracks cursor position and offsets of the editing window</td></tr>
</tbody></table>
</div>
<p>To keep the code simple, we'll code most functionalities in the Editor type,
while the others will be lightweight structs that never modify the state of the
editor.</p>
<h2 id="the-types-module-holds-all-our-types"><a class="header" href="#the-types-module-holds-all-our-types">The <code>types</code> module holds all our types</a></h2>
<p>Even though each of these types will have its own importable module, all other
modules will access them through the <code>src/types.zig</code> module, that serves as
a centralized hub for all our types.</p>
<p>We can do this because the program is small, but probably it wouldn't be a wise
thing to do in a large program. Still, also the Zig standard library often
makes types defined in submodules accessible from the root module. An example
is <code>std.ArrayList</code>.</p>
<p>We'll do it right away, open the <code>types</code> module and add this below the <code>Screen</code>
definition:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">pub const Editor = @import("Editor.zig");
pub const Buffer = @import("Buffer.zig");
pub const Row = @import("Row.zig");
pub const View = @import("View.zig");
</code></pre>
<p>The files don't exist yet, but we'll create them soon. We'll build up the types
little by little, adding more stuff only when we need it.</p>
<p>We also create a section for other miscellaneous types:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Other types
//
///////////////////////////////////////////////////////////////////////////////

/// A dynamical string.
pub const Chars = std.ArrayList(u8);
</code></pre>
<p>And the usual Constants section:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-editor-type"><a class="header" href="#the-editor-type">The Editor type</a></h1>
<p>Create <code>src/Editor.zig</code> and let's start adding the struct members. This is an
instantiable module, that's why the filename starts with a capital letter. It's
not enforced, but it's the Zig convention for types to be capitalized.</p>
<p>At the top, we add comments followed by an exclamation mark: it's the module
description. Such special comments may be used for documentation generation.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">//! Type that manages most of the editor functionalities.
//! It draws the main window, the statusline and the message area, and controls
//! the event loop.
</code></pre>
<p>At the bottom, we put our usual section with constants:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const Editor = @This();

const std = @import("std");

const t = @import("types.zig");
</code></pre>
<p><code>@This()</code> is a builtin function that returns the type of the struct. It is
capitalized like all functions that return types. This constant means that in
this file <code>Editor</code> refers to the same type we're defining. Others prefer to
name such constants <code>Self</code>. I prefer more descriptive names.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Back at the top, below the module description, we start adding the type
members:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Allocator used by the editor instance
alc: std.mem.Allocator,
</code></pre>
<p>We'll use a single allocator for now, the Editor will pass its own to the types
that will require it. We call the field simply <code>alc</code>, because it will be passed
so often as argument, that I prefer to keep the name short.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// The size of the terminal window where the editor runs
screen: t.Screen,

/// Text buffer the user is currently editing
buffer: t.Buffer,

/// Tracks cursor position and part of the buffer that fits the screen
view: t.View,

/// Becomes true when the main loop should stop, causing the editor to quit
should_quit: bool,
</code></pre>
<p>We didn't create the <code>Buffer</code> nor the <code>View</code> type yet.
<code>should_quit</code> is the variable that we'll use to control the main event loop.
When this variable becomes true, the loop is interrupted and the program quits.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>Now we'll create functions to initialize/deinitialize the editor:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Init/deinit
//
///////////////////////////////////////////////////////////////////////////////

/// Return the initialized editor instance.
pub fn init(allocator: std.mem.Allocator, screen: t.Screen) !Editor {
    return .{
        .alc = allocator,
        .screen = .{
            .rows = screen.rows - 2, // make room for statusline/message area
            .cols = screen.cols,
        },
        .buffer = try t.Buffer.init(allocator),
        .view = .{},
        .should_quit = false,
    };
}
</code></pre>
<p>This is a simple <code>init()</code> function that returns a new instance of the Editor.
It's not a <em>method</em> because its first argument is not of type <code>Editor</code>.
It is invoked in this way:</p>
<pre><code class="language-zig">    var editor = Editor.init(allocator, screen);
</code></pre>
<p>The <code>deinit()</code> function, on the other hand, is a proper <em>method</em>, because it is
used to deinitialize an instance.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Deinitialize the editor.
pub fn deinit(e: *Editor) void {
    e.buffer.deinit();
}
</code></pre>
<p>Accordingly, it is invoked like this:</p>
<pre><code class="language-zig">    editor.deinit();
</code></pre>
<p>Everything that has used an allocator should be deinitialized here. If you
forget to deinitialize/deallocate something, while still using the
<code>DebugAllocator</code>, you'll be told when exiting the program that your program has
leaked memory, and the relative stack trace.</p>
<p>We'll also add a method called <code>startUp()</code>. This function will handle the event
loop, and is also called from <code>main()</code>.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Start up the editor: open the path in args if valid, start the event loop.
pub fn startUp(e: *Editor, path: ?[]const u8) !void {
    if (path) |name| {
        _ = name;
        // we open the file
    }
    else {
        // we generate the welcome message
    }

    while (e.should_quit == false) {
        // refresh the screen
        // process keypresses
    }
}
</code></pre>
<p>It's only a stub, but you can see what it should do.</p>
<p>Before continuing the Editor type, we must define the other ones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-buffer-type"><a class="header" href="#the-buffer-type">The Buffer type</a></h1>
<p>Description at the top:</p>
<div class="code-title">Buffer.zig</div>
<pre><code class="language-zig">//! A Buffer holds the representation of a file, divided in rows.
//! If modified, it is marked as dirty until saved.
</code></pre>
<p>Let's add the constants: as usual, they'll stay at the bottom.</p>
<p>Also here we set a constant to <code>@This()</code>, so that we can refer to our type
inside its own definition.</p>
<div class="code-title">Buffer.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const Buffer = @This();

const std = @import("std");
const t = @import("types.zig");

/// Initial allocation size for Buffer.rows
const initial_rows_capacity = 40;
</code></pre>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<p>Also in this case, as you can see, no default initializers.</p>
<p>Some members are <em>optional</em>, meaning that they can be <code>null</code>, and <code>null</code> will
be their initial value when the Buffer is initialized.</p>
<div class="code-title">Buffer.zig</div>
<pre><code class="language-zig">alc: std.mem.Allocator,

// Modified state
dirty: bool,

// Buffer rows
rows: std.ArrayList(t.Row),

// Path of the file
filename: ?[]u8,

// Name of the syntax
syntax: ?[]const u8,
</code></pre>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>All in all, this type is quite simple. It doesn't handle single row
initialization, because rows are created and inserted by the Editor, but it
will deinitialize them. Possibly I'm doing a questionable choice here, maybe
I should let the Buffer initialize the single rows, since it's here that
they're freed at last. Especially if we intend to give a Buffer its own
different allocator (an <code>arena</code> allocator probably would fit it best). But it's
a small detail, since the Editor can access the <code>Buffer</code> allocator just fine,
since there are no private fields in Zig.</p>
<div class="code-title">Buffer.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Init/deinit
//
///////////////////////////////////////////////////////////////////////////////

pub fn init(allocator: std.mem.Allocator) !Buffer {
    return Buffer{
        .alc = allocator,
        .rows = try .initCapacity(allocator, initial_rows_capacity),
        .dirty = false,
        .filename = null,
        .syntax = null,
    };
}

pub fn deinit(buf: *Buffer) void {
    t.freeOptional(buf.alc, buf.filename);
    t.freeOptional(buf.alc, buf.syntax);
    for (buf.rows.items) |*row| {
        row.deinit(buf.alc);
    }
    buf.rows.deinit(buf.alc);
}
</code></pre>
<p>There is one new function, <code>freeOptional()</code>, which we didn't define yet.
It's a simple helper, but it doesn't harm to have some helper functions.
I put it in the <code>types</code> module, right above the bottom section:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Functions
//
///////////////////////////////////////////////////////////////////////////////

/// Free an optional slice if not null.
pub fn freeOptional(allocator: std.mem.Allocator, sl: anytype) void {
    if (sl) |slice| {
        allocator.free(slice);
    }
}
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="types/Buffer.html#admonition-note"></a>
</div>
<div>
<p>I put this function here only because the <code>types</code> module is accessed by most
other modules, so it's easily accessible. But since it doesn't return
a <strong>Type</strong>, I think it's slightly misplaced.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-row-type"><a class="header" href="#the-row-type">The Row type</a></h1>
<p>Description at the top:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">//! A Row contains 3 arrays, one for the actual characters, one for how it is
//! rendered on the screen, and one with the highlight of each element of the
//! rendered array.
</code></pre>
<p>Constants:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const Row = @This();

const std = @import("std");

const t = @import("types.zig");

const initial_row_size = 80;
</code></pre>
<p>Also for this type, we keep it simple: no operations are performed by it. We
will add more things to this type as soon as we need them, this is only
a partial implementation.</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">/// The ArrayList with the actual row characters
chars: t.Chars,

/// Array with the visual representation of the row
render: []u8,

///////////////////////////////////////////////////////////////////////////////
//
//                              Init/deinit
//
///////////////////////////////////////////////////////////////////////////////

pub fn init(allocator: std.mem.Allocator) !Row {
    return Row{
        .chars = try .initCapacity(allocator, initial_row_size),
        .render = &amp;.{},
    };
}

pub fn deinit(row: *Row, allocator: std.mem.Allocator) void {
    row.chars.deinit(allocator);
    allocator.free(row.render);
}
</code></pre>
<p>Some explanations:</p>
<ul>
<li>
<p>our <code>chars</code> field is a dynamic string, it contains the actual characters of
the row, it expands or shrinks as characters are typed/deleted. We set an
initial capacity, to reduce the need for later allocations.</p>
</li>
<li>
<p>the <code>render</code> field is a simple array of <code>u8</code>. This is probably not optimal,
but we'll see later if we can improve the implementation. The point is that
this array doesn't need to grow dynamically, when it is updated its new size
can be precalculated, so at most it would need a single reallocation, which may
result in no new allocation at all. For now we keep it simple.</p>
</li>
<li>
<p>as usual, the <code>init()</code> function returns a new instance, the <code>deinit()</code> method
frees the memory.</p>
</li>
</ul>
<p>We also add some methods that will help us keeping code concise:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Methods
//
///////////////////////////////////////////////////////////////////////////////

/// Length of the real row.
pub fn clen(row: *Row) usize {
    return row.chars.items.len;
}

/// Length of the rendered row.
pub fn rlen(row: *Row) usize {
    return row.render.len;
}
</code></pre>
<div id="admonition-zero-length-initialization" class="admonition admonish-note" role="note" aria-labelledby="admonition-zero-length-initialization-title">
<div class="admonition-title">
<div id="admonition-zero-length-initialization-title">
<p>Zero-length initialization</p>
</div>
<a class="admonition-anchor-link" href="types/Row.html#admonition-zero-length-initialization"></a>
</div>
<div>
<p>In this line</p>
<pre class="code-block-small"><code class="language-zig">.render = &.{},
</code></pre>
<p>you might wonder why that notation: <code>&amp;.{}</code>. It's a <em>zero-length</em> slice. The
<a href="https://ziglang.org/documentation/0.15.1/#Slices">official documentation</a>
says:</p>
<pre class="code-block-small"><code>A zero-length initialization can always be used to create an empty slice,
even if the slice is mutable. This is because the pointed-to data is zero
bits long, so its immutability is irrelevant.
</code></pre>
<p>It's different from initializing a slice to <code>undefined</code>, because here the slice
has a known length, which is <code>0</code>. So you can loop it safely, provided that
you check its length and don't access any index, since it's empty.</p>
<pre class="code-block-small"><code class="language-zig">for (&.{}) |c| {} // ok
</code></pre>
<p>I think it's always preferable to initialize a slice this way, rather than with
<code>undefined</code>.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-view-type"><a class="header" href="#the-view-type">The View type</a></h1>
<p>This type only contains fields. This is the full type, nothing more will be
added. It tracks the cursor position and the portion of the buffer that is
shown in the main window.</p>
<div class="code-title">View.zig</div>
<pre><code class="language-zig">//! A View of the current buffer is what we can see of it, and where the
//! cursor lies in it. It's basically the editor window where the file is
//! shown.

/// cursor column
cx: usize = 0,

/// cursor line
cy: usize = 0,

/// column in the rendered row
rx: usize = 0,

/// wanted column when moving vertically across shorter lines
cwant: usize = 0,

/// the top visible line, increases as we scroll down
rowoff: usize = 0,

/// the leftmost visible column
coloff: usize = 0,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="digression-default-initializers"><a class="header" href="#digression-default-initializers">Digression: default initializers</a></h1>
<p>When defining the <code>Screen</code> type, I wrote that Zig supports default initializers
for structs, with a catch. The catch is that they may be the source of illegal
behaviors, as stated by the <a href="https://ziglang.org/documentation/master/#toc-Faulty-Default-Field-Values">official language
reference</a>.</p>
<p>In the example from that link, it's not too clear at first sight what's the
problem in that struct is, so it's worth pointing it out.</p>
<p>Given this struct:</p>
<pre><code class="language-zig">const Threshold = struct {
    minimum: f32 = 0.25,
    maximum: f32 = 0.75,

    fn validate(t: Threshold, value: f32) void {
        assert(t.maximum &gt;= t.minimum);
    }
};
</code></pre>
<p>If we create a variable like this:</p>
<pre><code>var a = Threshold{ .maximum = 0.2 };
</code></pre>
<p>we created a variable where the maximum is smaller than the minimum, and the
<code>validate()</code> function would panic at runtime. So if in your code you rely on
the assumption that <code>maximum</code> is always greater than <code>minimum</code>, you could fall
into some illegal behavior.</p>
<p>For this reason in this program I avoid default initializers for complex types
that have methods, which may
access those values. I only use them for simple types without methods, because
it's hard to give up the convenience of being able to write:</p>
<pre><code>var a = SomeType{};
</code></pre>
<p>For more complex types I use a <code>init()</code> function that returns the
instance, as it's customary to have such functions, and set default values
there.</p>
<h3 id="undefined-as-default-value"><a class="header" href="#undefined-as-default-value"><a href="https://ziglang.org/documentation/master/#undefined">undefined</a> as default value</a></h3>
<p><code>undefined</code> is generally used for local variables whose lifetime is limited and
obvious, as obvious is the place where they acquire a meaningful value. The
compiler will not warn you if you use variable set to <code>undefined</code>. Instead, it
will warn you if you don't initialize a member. Therefore you should have
a really good reason to set an <code>undefined</code> default value inside structs.</p>
<p>Anyway, why using <code>undefined</code> at all? For example, sometimes you need
a variable declared beforehand in an upper scope. In this case, setting it to
a value that it is meant to be overwritten would cause confusion: why am
I setting it to that value? The intent of <code>undefined</code> is clear instead: this
variable <em>must</em> acquire a meaningful value later on.</p>
<p><a href="https://ziggit.dev/t/port-of-kilo-editor-to-zig/11463/13">Sze from the Ziggit forum says:</a></p>
<p>You are telling the compiler that you <strong>want</strong> the value to be undefined.
And there aren’t enough safety checks yet so that all ways to use such an
undefined value would be caught reliably. So for now you have to be careful and
it is better to only use undefined, when you are making sure that you are
setting it to a valid value before you actually use it.
In cases where some field sometimes needs to be set to undefined, it is better
to avoid using a field default value for that and instead pass undefined for
that field value explicitly during initialization/setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize-the-editor"><a class="header" href="#initialize-the-editor">Initialize the editor</a></h1>
<p>Let's open <code>main.zig</code> and initialize the editor. Add this to the <code>main()</code>
function:</p>
<div class="code-diff-removed">
<pre><code>    _ = allocator;
</code></pre>
</div>
<pre><code class="language-zig">    var e = try t.Editor.init(allocator, try ansi.getWindowSize());
    defer e.deinit();

    var args = std.process.args();
    _ = args.next(); // ignore first arg

    try e.startUp(args.next()); // possible file to open
</code></pre>
<p>If you remember, the <code>Editor.init()</code> function had this signature:</p>
<pre><code class="language-zig">pub fn init(allocator: std.mem.Allocator, screen: t.Screen) !Editor
</code></pre>
<p>which means that, besides an allocator, it wants to know the size of the
screen, which is what <code>getWindowSize()</code> fetches.</p>
<p>If the <code>ansi</code> and <code>types</code> modules aren't being imported, add them to the
constants.</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">const t = @import("types.zig");
const ansi = @import("ansi.zig");
</code></pre>
<p>Next we process the command line arguments, we skip the first one, since it's
the name of our executable, finally we start up the editor passing the second
argument, which could be <code>null</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keypress-processing"><a class="header" href="#keypress-processing">Keypress processing</a></h1>
<p>Before starting to draw anything, let's handle keypresses, because it's easier,
shorter, and as a bonus we'll have a way to quit the editor if we build it
(remember that our raw mode disables <kbd>Ctrl-C</kbd>).</p>
<p>By the way, did you follow my advice to install <code>ctags</code>? Because from now on,
we'll move very often from function to function, file to file, and having to
spend half a minute to find something kills completely the fun, believe me.</p>
<p>This is our event loop in <code>Editor.startUp()</code>:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    while (e.should_quit == false) {
        // refresh the screen
        // process keypresses
    }
</code></pre>
</div>
<pre><code class="language-zig">    while (e.should_quit == false) {
        // refresh the screen
        try e.processKeypress();
    }
</code></pre>
<p>Let's create the function:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Keys processing
//
///////////////////////////////////////////////////////////////////////////////

/// Process a keypress: will wait indefinitely for readKey, which loops until
/// a key is actually pressed.
fn processKeypress(e: *Editor) !void {
    const k = try ansi.readKey();

    const static = struct {
        var q: u8 = 3;
    };

    switch (k) {
        .ctrl_q =&gt; {
            if (static.q &gt; 1) {
                static.q -= 1;
                return;
            }
            try ansi.clearScreen();
            e.should_quit = true;
        },
        else =&gt; {},
    }

    // reset quit counter for any keypress that isn't Ctrl-Q
    static.q = 3;
}
</code></pre>
<p>This function calls <code>ansi.readKey()</code> (which we didn't write yet), then handle
the keypress. The only keypress that we handle for now is <kbd>Ctrl-Q</kbd>,
and we want to press it 3 times in a row before quitting.</p>
<p>It needs to import <code>ansi.zig</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const ansi = @import("ansi.zig");
</code></pre>
<h3 id="static-variables-in-zig"><a class="header" href="#static-variables-in-zig">Static variables in Zig</a></h3>
<p>See that <code>static</code> struct? Zig doesn't have the concept of static variables that
are local to a function, like in C. But you can achieve the same effect by
declaring a constant struct inside the function, and define <em>variables</em> (not
fields!) inside of it. You don't need to call it <code>static</code>, of course, it can
have any name.</p>
<p>And that <code>.ctrl_q</code>? It's an enum field, of an enum that we didn't write yet.</p>
<div id="admonition-things-were-missing" class="admonition admonish-note" role="note" aria-labelledby="admonition-things-were-missing-title">
<div class="admonition-title">
<div id="admonition-things-were-missing-title">
<p>Things we're missing</p>
</div>
<a class="admonition-anchor-link" href="keypress/keypress.html#admonition-things-were-missing"></a>
</div>
<div>
<p>We can't compile yet. We must add:</p>
<ul>
<li><code>Key</code> enum</li>
<li><code>ansi.readKey()</code></li>
<li><code>ansi.clearScreen()</code></li>
</ul>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-key-enum"><a class="header" href="#the-key-enum">The Key enum</a></h1>
<p>Let's start with the enum, it will be placed in the 'other types' section of
the <code>types</code> module:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// ASCII codes of the keys, as they are read from stdin.
pub const Key = enum(u8) {
    ctrl_b = 2,
    ctrl_c = 3,
    ctrl_d = 4,
    ctrl_f = 6,
    ctrl_g = 7,
    ctrl_h = 8,
    tab = 9,
    ctrl_j = 10,
    ctrl_k = 11,
    ctrl_l = 12,
    enter = 13,
    ctrl_q = 17,
    ctrl_s = 19,
    ctrl_t = 20,
    ctrl_u = 21,
    ctrl_z = 26,
    esc = 27,
    backspace = 127,
    left = 128,
    right = 129,
    up = 130,
    down = 131,
    del = 132,
    home = 133,
    end = 134,
    page_up = 135,
    page_down = 136,
    _,
};
</code></pre>
<p>This is a <a href="https://ziglang.org/documentation/master/#Non-exhaustive-enum">non-exhaustive
enum</a>: it has an
underscore as last element.</p>
<p>Generally, enums are a strongly namespaced type. You can't infer an integer
from it, if that <em>enum</em> doesn't have a <em>member</em> with that value.
<em>Non-exhaustive</em> enums are more permissive: they are like a set of all integers
of a certain type, some of which have been given a name.</p>
<p>This means that we will be able to cast an integer to an enum member (with
<code>@enumFromInt</code>), even if the <em>enum</em> doesn't have a <em>member</em> for that integer.</p>
<p>Why do we want this? Because we aren't going to give a name to all possible
keys:</p>
<ul>
<li><code>readKey()</code> will read <code>u8</code> characters through <code>readChars()</code></li>
<li><code>readKey()</code> will return a <code>Key</code>, so it must be able turn any <code>u8</code> character
into a <code>Key</code> enum member</li>
</ul>
<p>But this character may be a letter, a digit, or anything that doesn't have
a field in that enum. We want to full interoperation with all possible <code>u8</code>
values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-keys"><a class="header" href="#reading-keys">Reading keys</a></h1>
<p>The <code>ansi</code> module needs a new constant, from the Zig standard library:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">const asc = std.ascii;
</code></pre>
<p>Let's write <code>ansi.readKey()</code>.</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Read a character from stdin. Wait until at least one character is
/// available.
pub fn readKey() !t.Key {
    // code to come...
}
</code></pre>
<p>We'll use a <code>[4]u8</code> buffer to store the keys that will be read. We'll feed this
to the same <code>readChars()</code> that we've used before.</p>
<div class="code-title">ansi.zig: readKey()</div>
<pre><code class="language-zig">    // we read a sequence of characters in a buffer
    var seq: [4]u8 = undefined;
    const nread = try linux.readChars(&amp;seq);

    // if the first character is ESC, it could be part of an escape sequence
    // in this case, nread will be &gt; 2, that means that more than two
    // characters have been read into the buffer, and it's an escape sequence
    // for sure, if we can't recognize this sequence we return ESC anyway
</code></pre>
<p>If you remember, that function has a loop that ignores <code>.WouldBlock</code> errors,
and it's guaranteed to read at least one byte from <code>stdin</code> before returning. If
the keypress is a special key which uses CSI escape sequences, there will be
more characters. We read up to 4 characters, then we decide what to do with
them.</p>
<p>You can verify that the sequences are correct by opening a terminal, pressing
<kbd>Ctrl-V</kbd> and then the key. For example:</p>
<div class="table-wrapper"><table><thead><tr><th>keys</th><th>sequence</th><th>character-by-character</th></tr></thead><tbody>
<tr><td><kbd>Ctrl-V</kbd><kbd>Left</kbd></td><td><code>^[[D</code></td><td><code>ESC [ D</code></td></tr>
<tr><td><kbd>Ctrl-V</kbd><kbd>Del</kbd></td><td><code>^[[~3</code></td><td><code>ESC [ ~ 3</code></td></tr>
</tbody></table>
</div>
<p>We use <code>@enumFromInt</code> to cast a character in the sequence to a <code>Key</code> enum
member, which might not be defined, but it won't be a problem since our enum is
non-exhaustive.</p>
<div class="code-title">ansi.zig: readKey()</div>
<pre><code class="language-zig">    const k: t.Key = @enumFromInt(seq[0]);
</code></pre>
<p>Note that this function doesn't guarantee that we interpret all possible escape
sequences: if a sequence isn't recognized, ESC is returned.</p>
<p>We also handle the case that more than one character has been read, but it's
not an escape sequence (<code>nread &gt; 1</code>). It's possibly a multi-byte character and
we don't handle those, so we return ESC.</p>
<p>If instead it's a single character, it is returned as-is.</p>
<div class="code-title">ansi.zig: readKey()</div>
<pre><code class="language-zig">    if (k == .esc and nread &gt; 2) {
        if (seq[1] == '[') {
            if (nread &gt; 3 and asc.isDigit(seq[2])) {
                if (seq[3] == '~') {
                    switch (seq[2]) {
                        '1' =&gt; return .home,
                        '3' =&gt; return .del,
                        '4' =&gt; return .end,
                        '5' =&gt; return .page_up,
                        '6' =&gt; return .page_down,
                        '7' =&gt; return .home,
                        '8' =&gt; return .end,
                        else =&gt; {},
                    }
                }
            }
            switch (seq[2]) {
                'A' =&gt; return .up,
                'B' =&gt; return .down,
                'C' =&gt; return .right,
                'D' =&gt; return .left,
                'H' =&gt; return .home,
                'F' =&gt; return .end,
                else =&gt; {},
            }
        }
        else if (seq[1] == 'O') {
            switch (seq[2]) {
                'H' =&gt; return .home,
                'F' =&gt; return .end,
                else =&gt; {},
            }
        }
        return .esc;
    }
    else if (nread &gt; 1) {
        return .esc;
    }
    return k;
</code></pre>
<h3 id="clearscreen"><a class="header" href="#clearscreen"><code>clearScreen()</code></a></h3>
<p>We also add a <code>clearScreen()</code> function:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Clear the screen.
pub fn clearScreen() !void {
    try linux.write(ClearScreen);
}
</code></pre>
<p>At this point, if we compile and run we should get an empty prompt, if we then
press <kbd>Ctrl-Q</kbd> three times in a row the program should clear the
screen and quit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-and-writing"><a class="header" href="#reading-and-writing">Reading and Writing</a></h1>
<p>Before we can draw anything, we must be able to open a file, read all of its
lines and store them in our Buffer.</p>
<p>In <code>main()</code>, the first command line argument is passed to the
<code>Editor.startUp()</code> function. If it is non-null, the file will be opened if
existing.</p>
<p>To handle read/write operations, we'll use the <code>Io.Reader</code> and <code>Io.Writer</code>
interfaces. They have methods to process incoming/outcoming data and can do
buffered reading and writing. They are <em>interfaces</em>, meaning that independently
from what they are attached to, they have the same way of operating. So if you
read from <em>stdin</em> or from a file, you'll have access to the same ways of
processing data.</p>
<p>They have been only recently added to the Zig standard library and are a vast
subject, so I will only mention that they exist, and that we'll be using them
for some tasks.</p>
<p>For now we can only read a file, because we don't have the means to fill our
Buffer rows yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opening-a-file"><a class="header" href="#opening-a-file">Opening a file</a></h1>
<p>In order, we're going to:</p>
<ul>
<li>
<p>update our buffer filename, to match the path of the file we're going to
open</p>
</li>
<li>
<p>try to open the file itself and read its lines</p>
</li>
<li>
<p>if that fails, we start editing an empty file with the given name</p>
</li>
</ul>
<p>Let's update our <code>Editor.startUp()</code>:</p>
<div class="code-title">Editor.zig: startUp()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    if (path) |name| {
        _ = name;
        // we open the file
    }
</code></pre>
</div>
<pre><code class="language-zig">    if (path) |name| {
        try e.openFile(name);
    }
</code></pre>
<p>Just below <code>startUp()</code>, we inaugurate a new section for file operations, and we
add an <code>openFile()</code> function:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              File operations
//
///////////////////////////////////////////////////////////////////////////////

/// Open a file with `path`.
fn openFile(e: *Editor, path: []const u8) !void {
    // code to come...
}
</code></pre>
<h3 id="naming-the-buffer"><a class="header" href="#naming-the-buffer">Naming the buffer</a></h3>
<p>We update the buffer name from the <code>path</code> argument:</p>
<div class="code-title">Editor.zig: openFile()</div>
<pre><code class="language-zig">    var B = &amp;e.buffer;

    // store the filename into the buffer
    B.filename = try e.updateString(B.filename, path);
</code></pre>
<p>To update the filename, we write a helper function (I put the Helpers section
at the bottom, above the Constants section):</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Helpers
//
///////////////////////////////////////////////////////////////////////////////

/// Update the string, freeing the old one and allocating from `path`.
fn updateString(e: *Editor, old: ?[]u8, path: []const u8) ![]u8 {
    t.freeOptional(e.alc, old);
    return try e.alc.dupe(u8, path);
}
</code></pre>
<p>For now we can't rename a buffer, so the old filename will always be <code>null</code>.
Which is OK <em>only</em> because we made our <code>Buffer.filename</code> an optional type.</p>
<h3 id="open-the-file"><a class="header" href="#open-the-file">Open the file</a></h3>
<p>After having stored the new filename into the Buffer, we try to open the file.
<code>std.fs.cwd().openFile()</code> is how we open files, and it works on both relative
and absolute paths, so we don't have to worry about that.</p>
<div class="code-title">Editor.zig: openFile()</div>
<pre><code class="language-zig">    // read lines if the file could be opened
    const file = std.fs.cwd().openFile(path, .{ .mode = .read_only });
    if (file) |f| {
        defer f.close();
        try e.readLines(f);
    }
</code></pre>
<p><code>openFile()</code> expects an
<a href="https://ziglang.org/documentation/0.15.1/std/#std.fs.File.OpenMode">OpenMode</a>
enum value, which is one of the following:</p>
<div class="code-title">std.fs.File</div>
<pre><code class="language-zig">pub const OpenMode = enum {
    read_only,
    write_only,
    read_write,
};
</code></pre>
<p>We're opening to read, so our <code>.mode</code> is <code>.read_only</code>.</p>
<p>The function <code>openFile()</code> returns an error union, so we must do a capture on
our <code>if</code> statement, to get the value, or handle the error. If the file doesn't
exist (<code>error.FileNotFound</code>) we don't want to quit, instead we assume we're
editing a new file. If the file exists, we read its lines, without forgetting
to <code>close()</code> the file handle.</p>
<div class="code-title">Editor.zig: openFile()</div>
<pre><code class="language-zig">    else |err| switch (err) {
        error.FileNotFound =&gt; {}, // new unsaved file
        else =&gt; return err,
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioreader"><a class="header" href="#ioreader">Io.Reader</a></h1>
<p><code>std.fs.File</code> implements the <code>Io.Reader</code> interface, so we'll use that to read
its lines. A simple pattern would be like the following:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Read all lines from file.
fn readLines(e: *Editor, file: std.fs.File) !void {
    _ = e;
    var buf: [1024]u8 = undefined;
    var reader = file.reader(&amp;buf);

    while (reader.interface.takeDelimiterExclusive('\n')) |line| {
        // we print the line to stderr, to see if it works
        std.debug.print("{s}\n", .{line});
    }
    else |err| if (err != error.EndOfStream) return err;
}
</code></pre>
<p><code>file</code> is the file that has already been opened and is ready to be read.
We create a buffer on the stack, then we initialize its reader. <code>Io.Reader</code>
actually lives in <code>reader.interface</code>, so <code>Io.Reader</code> methods will be called on
the interface.</p>
<p>We stop at error <code>.EndOfStream</code>, which means our file has been fully read.
Other errors instead should be handled.</p>
<p>Now, this implementation is simple, but it has a problem: the buffer is on the
stack, and has fixed size. Which means that we can't read lines longer than its
size. If a file has lines that are longer than that, it will error out. We'll
fix this later.</p>
<p>Anyway, let's test this. Create a file named <code>kilo</code> at the root of the project:</p>
<div class="code-title">~/kilo-zig/kilo</div>
<pre><code class="language-sh">#!/bin/sh

~/kilo-zig/zig-out/bin/kilo "$@" 2&gt;err.txt
</code></pre>
<p>Then</p>
<pre><code>chmod u+x kilo
</code></pre>
<p>It will run the program and write <code>stderr</code> output to <code>err.txt</code>. Compile and run
with an argument, the lines of the file should be written into <code>err.txt</code>:</p>
<pre><code>./kilo src/main.zig
</code></pre>
<p>Remember that we still have to press 3 times <kbd>Ctrl-Q</kbd> to quit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="digression-assignments-in-zig"><a class="header" href="#digression-assignments-in-zig">Digression: assignments in Zig</a></h1>
<p>In Zig, it's really important that you pay attention to details, which, if you
have mainly experience with OOP languages, you may find confusing or even
frustrating. It has to do with the fact that in Zig, as in C, all assignments
imply a copy <em>by value</em>.</p>
<p>This is especially important when assigning <code>struct</code> values. Most OOP
languages, when assigning <em>objects</em>, take a <em>reference</em> to it. But in Zig
structs are not references, they are <em>values</em>, and they are <em>copied</em> when
assigned.</p>
<h3 id="the-case-of-the-ioreader-interface"><a class="header" href="#the-case-of-the-ioreader-interface">The case of the Io.Reader interface</a></h3>
<p>The interface is a nested struct in the reader. To work, it uses a builtin
function called <code>@fieldParentPtr()</code> that desumes the address of its parent, so
that the interface knows the address of the struct that contains it. But if
instead of writing:</p>
<pre><code>var reader = file.reader(&amp;buf);
while (reader.interface.takeDelimiterExclusive('\n')) |line|
</code></pre>
<p>you write:</p>
<pre><code>var reader = file.reader(&amp;buf).interface;
while (reader.takeDelimiterExclusive('\n')) |line|
</code></pre>
<p>then you make a <em>copy</em> of that interface, which is orphan, can't take a valid
address of its parent because it doesn't have one, and is essentially broken.</p>
<p>There's also the problem that <code>file.reader(&amp;buf)</code>, which is the legitimate
parent, in the second form doesn't have a stable address, because it's not
assigned to any variable, meaning that in the second expression it's temporary
memory that becomes immediately invalid at the end of the assignment. So even
if <code>interface</code> wasn't a copy and could still get its address, it would be
invalid memory anyway.</p>
<p>The program will panic at runtime (in safe builds!), and the error reported can
be hard to understand. Unfortunately Zig documentation is still immature, so
right now you'll have to find out the hard way how these things work.</p>
<p>These kind of issues can be frustrating if you're used to OOP languages, which
are generally designed to perform complex operations under the hood, hiding the
details of the implementation from the user, for the sake of easiness of use.</p>
<p>In OOP languages when you <em>assign</em> something, often you aren't copying by
<em>value</em>, but you are taking a <em>reference</em> to an object. In Zig you are expected
to understand what assignments do (they always copy by <em>value</em>), and what you
are really assigning.</p>
<p>Other example, many OOP languages have <em>private</em> fields, which can't be
accessed outside of a certain scope. Zig has nothing like that, and everything
is in plain sight, but it expects that you know what you're doing. As the
creator of Zig <a href="https://ziggit.dev/t/0-15-1-reader-writer/11614/26">said</a>:</p>
<pre><code>it all comes down to simplicity. Other languages hide complex details from
you; Zig keeps things simpler but in exchange requires you to understand
those details.
</code></pre>
<p>That said, there's probably room for improvement, and possibly there will be
ways, in the future, to at least prevent accidental mistakes.</p>
<h4 id="interesting-discussions-and-posts"><a class="header" href="#interesting-discussions-and-posts">Interesting discussions and posts</a></h4>
<ul>
<li><a href="https://ziggit.dev/t/zig-0-15-1-reader-writer-dont-make-copies-of-fieldparentptr-based-interfaces/11719">discussion</a></li>
<li><a href="https://ziggit.dev/t/zig-0-15-1-reader-writer-dont-make-copies-of-fieldparentptr-based-interfaces/11719/7">post</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filling-rows"><a class="header" href="#filling-rows">Filling rows</a></h1>
<p>Now that we can read a file line by line, we must store these lines in our
Buffer rows.</p>
<p>We'll modify <code>readLines()</code> so that it will insert the row.</p>
<div class="code-title">Editor.zig: readLines()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    _ = e;
</code></pre>
</div>
<pre><code class="language-zig">    var buf: [1024]u8 = undefined;
    var reader = file.reader(&amp;buf);
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">    while (reader.interface.takeDelimiterExclusive('\n')) |line| {
        // we print the line to stderr, to see if it works
        std.debug.print("{s}\n", .{line});
</code></pre>
</div>
<pre><code class="language-zig">    while (reader.interface.takeDelimiterExclusive('\n')) |line| {
        try e.insertRow(e.buffer.rows.items.len, line);
</code></pre>
<p>which means that we'll insert a row at the last index of <code>Buffer.rows</code>.</p>
<h3 id="watch-out-the-reading-buffer"><a class="header" href="#watch-out-the-reading-buffer">Watch out the reading buffer</a></h3>
<p>We'll also fix one problem of the current way we're reading the file. We're
using a fixed buffer which is placed on the stack, and that's ok, because our
<code>file.reader</code> needs a buffer. But the way this reader works, is that this
buffer is filled with the line that is being read, then a row is inserted with
the content of this buffer.</p>
<p>If the line is longer than the buffer, the program will quit with an error:</p>
<pre><code>error: StreamTooLong
</code></pre>
<p>I don't know if there's a way to salvage the line that has just been read and
be able to handle the error in the <code>else</code> branch. My first guess is <em>no</em>.</p>
<p>We could allocate a very large buffer and use that:</p>
<pre><code class="language-zig">    const buf = try e.alc.alloc(u8, 60 * 1024 * 1024);
    defer e.alc.free(buf);
    var reader = file.reader(buf);
</code></pre>
<p>But this approach has multiple problems:</p>
<ul>
<li>it's very slow, because allocating such a large buffer is expensive</li>
<li>we could get a <code>OutOfMemory</code> error</li>
<li>it doesn't solve the problem that you might still have files with lines
longer than that</li>
</ul>
<h3 id="using-an-allocating-reader"><a class="header" href="#using-an-allocating-reader">Using an allocating Reader</a></h3>
<p>So we use another solution (suggested on <a href="https://ziggit.dev/t/0-15-1-reader-writer/11614/9">Ziggit
forum</a>):</p>
<div class="code-title">Editor.zig: readLines()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    while (reader.interface.takeDelimiterExclusive('\n')) |line| {
        try e.insertRow(e.buffer.rows.items.len, line);
    }
    else |err| if (err != error.EndOfStream) return err;
</code></pre>
</div>
<pre><code class="language-zig">    var line_writer = std.Io.Writer.Allocating.init(e.alc);
    defer line_writer.deinit();

    while (reader.interface.streamDelimiter(&amp;line_writer.writer, '\n')) |_| {
        try e.insertRow(e.buffer.rows.items.len, line_writer.written());
        line_writer.clearRetainingCapacity();
        reader.interface.toss(1); // skip the newline
    }
    else |err| if (err != error.EndOfStream) return err;
</code></pre>
<p>This approach makes the reader not store the line it is reading in a <code>line</code>
slice, but it will feeding it to an allocating <code>Writer</code>, that stores the line
in itself, allocating as much as it is needed.</p>
<p>It uses another method of the <code>Reader</code> interface:</p>
<ul>
<li>
<p>instead of <code>takeDelimiterExclusive</code>, which doesn't take a <code>Writer</code> as
argument, it will use <code>streamDelimiter</code>, which does</p>
</li>
<li>
<p>it must toss the last character, because <code>streamDelimiter</code> doesn't skip it,
like <code>takeDelimiterExclusive</code> would do</p>
</li>
</ul>
<h3 id="way-too-complex"><a class="header" href="#way-too-complex">Way too complex?</a></h3>
<p>You can see that this is quite complex. I needed the help of experienced Zig
users just to read the lines of the file. But this is a temporary problem,
because the <code>Reader</code> and <code>Writer</code> interfaces are very new, and they still lack
convenience, which has been already been promised and will come soon in the
next Zig versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inserting-a-row"><a class="header" href="#inserting-a-row">Inserting a row</a></h1>
<p>If you remember, our <code>Row</code> type had two arrays:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">/// The ArrayList with the actual row characters
chars: t.Chars,

/// Array with the visual representation of the row
render: []u8,
</code></pre>
<p>where <code>Chars</code> is actually a <code>std.ArrayList(u8)</code>, which we'll be using a lot.</p>
<p>In our <code>insertRow()</code> function, what we'll do is:</p>
<ul>
<li>initialize a new <code>Row</code></li>
<li>copy the line into <code>row.chars</code></li>
<li>insert the row in <code>Buffer.rows</code></li>
</ul>
<p>Finally we'll update the row, and set the <code>dirty</code> flag.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Row operations
//
///////////////////////////////////////////////////////////////////////////////

/// Insert a row at index `ix` with content `line`, then update it.
fn insertRow(e: *Editor, ix: usize, line: []const u8) !void {
    const B = &amp;e.buffer;

    var row = try t.Row.init(B.alc);
    try row.chars.appendSlice(B.alc, line);

    try B.rows.insert(B.alc, ix, row);

    try e.updateRow(ix);
    B.dirty = true;
}
</code></pre>
<p>We set the <em>dirty</em> flag because the same function will be used while modifying
the buffer, but for now we're just reading the file. This flag will be reset in
<code>openFile()</code>.</p>
<p>Add this at the bottom of <code>openFile()</code>:</p>
<div class="code-title">Editor.zig: openFile()</div>
<pre><code class="language-zig">    else |err| switch (err) {
        error.FileNotFound =&gt; {}, // new unsaved file
        else =&gt; return err,
    }
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    B.dirty = false;
</code></pre>
</div>
<pre><code class="language-zig">}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-a-row"><a class="header" href="#updating-a-row">Updating a row</a></h1>
<p>Updating the row means that we must update the <code>render</code> field from the <code>chars</code>
field. That is, we must generate what will be actually rendered on screen.</p>
<p>The only way they will differ, at this point, is given by the possible presence
of tab characters in our <code>chars</code> ArrayList.</p>
<p>Let's say we want to make this <code>tabstop</code> an option, so that it can be
configured. We create a <code>src/option.zig</code> file and paste the following:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">//! Editor options. For now they are hard-coded and cannot be modified from
//! inside the editor, neither are read from a configuration file.

/// Number of spaces a tab character accounts for
pub var tabstop: u8 = 8;
</code></pre>
<p>As the description says, they're hard coded, but we'll still use a module, so
that we can test different options ourselves if we want.</p>
<p>We'll also have to import it in the Constants section:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const opt = @import("option.zig");
</code></pre>
<h3 id="rowat-and-currentrow"><a class="header" href="#rowat-and-currentrow">rowAt() and currentRow()</a></h3>
<p>We'll write other helper functions that we'll use a lot:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Get the row pointer at index `ix`.
fn rowAt(e: *Editor, ix: usize) *t.Row {
    return &amp;e.buffer.rows.items[ix];
}

/// Get the row pointer at cursor position.
fn currentRow(e: *Editor) *t.Row {
    return &amp;e.buffer.rows.items[e.view.cy];
}
</code></pre>
<p>Because frankly, to take that pointer all the times becomes annoying after
a while.</p>
<p>We shouldn't worry about performance loss for too many function calls: Zig
lacks macros, so the compiler tries to inline small functions when it can.
Writing small functions is actually the Zig way to write macros.</p>
<h3 id="updaterow"><a class="header" href="#updaterow">updateRow()</a></h3>
<p>The purpose of this function is to update the <em>rendered</em> row, which is what we
see on screen.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Update row.render, that is the visual representation of the row.
/// Performs a syntax update at the end.
fn updateRow(e: *Editor, ix: usize) !void {
    // code to come...
}
</code></pre>
<h3 id="allocatorrealloc"><a class="header" href="#allocatorrealloc">Allocator.realloc()</a></h3>
<div class="code-title">Editor.zig: updateRow()</div>
<pre><code class="language-zig">    const row = e.rowAt(ix);

    // get the length of the rendered row and reallocate
    const rlen = // ??? total size of the rendered row ???
    row.render = try e.alc.realloc(row.render, rlen);
</code></pre>
<p>As explained before, I chose to make <code>row.render</code> a simple array because we can
desume its size before any reallocation happens. Most of the time
a reallocation would not result in a new allocation, because <code>realloc()</code> does
the following:</p>
<ul>
<li>if the previous size is 0 (first time the row is updated) and new size is
bigger, there is an allocation</li>
<li>if the new size is smaller (characters are deleted), it is resized</li>
<li>if the new size is slightly bigger (such as when inserting a single
character while typing), most of the times it will extend the array without
reallocating</li>
<li>it would only allocate when the size is bigger and it's not possible to
extend the array</li>
</ul>
<p>An ArrayList would bring some benefits, but also increase total memory usage.
For now we'll keep it simple, but we'll keep it in mind.</p>
<h3 id="looping-characters-of-the-real-row"><a class="header" href="#looping-characters-of-the-real-row">Looping characters of the real row</a></h3>
<div class="code-title">Editor.zig: updateRow()</div>
<pre><code class="language-zig">    var idx: usize = 0;
    var i: usize = 0;

    while (i &lt; row.chars.items.len) : (i += 1) {
        if (row.chars.items[i] == '\t') {
            row.render[idx] = ' ';
            idx += 1;
            while (idx % opt.tabstop != 0) : (idx += 1) {
                row.render[idx] = ' ';
            }
        }
        else {
            row.render[idx] = row.chars.items[i];
            idx += 1;
        }
    }
</code></pre>
<p>What the loop does, is that it inserts in <code>row.render</code> the same character when
it's not a tab, otherwise it will convert it to spaces, making some
considerations in the process:</p>
<ul>
<li>inside the loop, <code>idx</code> is the current column in the rendered row</li>
<li>we want a minimum of one space, so we add it, and increase <code>idx</code></li>
<li>we want to see if there are more spaces to add, and this is true if <code>(idx % tabstop != 0)</code></li>
</ul>
<p>For example, assuming <code>tabstop = 8</code>, at the start of a line, where <code>idx</code> is 0,
a <kbd>Tab</kbd> would insert 8 spaces.</p>
<p>But a <kbd>Tab</kbd> typed in the middle of a row won't add necessarily
<code>tabstop</code> spaces, because the starting column in the rendered row may be such
that <code>idx % 8</code> is greater than 1, so if we insert a tab at <code>idx = 12</code>, we have
a space insertion, which makes <code>idx = 13</code>, then 5 more spaces, because <code>13 % 8 = 5</code>.</p>
<h3 id="computing-beforehand-the-size-of-the-rendered-row"><a class="header" href="#computing-beforehand-the-size-of-the-rendered-row">Computing beforehand the size of the rendered row</a></h3>
<pre><code class="language-zig">    // get the length of the rendered row and reallocate
    const rlen = // ??? total size of the rendered row ???
    row.render = try e.alc.realloc(row.render, rlen);
</code></pre>
<p>We didn't assign anything to <code>rlen</code>. How do we know how long will be our
rendered row? We'll have do something similar to what we do inside the loop in
<code>updateRow()</code>, but we just increase <code>idx</code> and return the final value. But often
in our program we'll have to convert a real column index to an index in the
rendered row, so we write a function that does that.</p>
<p>We call the function <code>cxToRx()</code> and the call becomes:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    const rlen = // ??? total size of the rendered row ???
</code></pre>
</div>
<pre><code class="language-zig">    const rlen = row.cxToRx(row.chars.items.len);
</code></pre>
<p>That is, we calculate the index in the rendered row for the last column of the
real row.</p>
<p>We put this function in <code>Row.zig</code>, because it is in agreement with how we
wanted to design our types: they shouldn't change the state of the Editor, but
they can return their own state. Here Row will not modify itself, so it's ok.</p>
<div class="code-title">Row.zig: methods section</div>
<pre><code class="language-zig">/// Calculate the position of a real column in the rendered row.
pub fn cxToRx(row: *Row, cx: usize) usize {
    var rx: usize = 0;
    for (0..cx) |i| {
        if (row.chars.items[i] == '\t') {
            rx += (opt.tabstop - 1) - (rx % opt.tabstop);
        }
        rx += 1;
    }
    return rx;
}
</code></pre>
<p>The loop is a bit different here, because instead of two nested loops we have
only one. That's because we don't need to modify the row in any way, so we can
calculate the needed spaces in a single operation. Which is quite a bit more
difficult to understand, to be honest. Feel free to recreate an example loop
step by step as we did above.</p>
<p>Also this function needs to import <code>option.zig</code>, so do that.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="fillrows/updateRow.html#admonition-note"></a>
</div>
<div>
<p>We don't handle multi-byte characters, and we don't have virtual text of any
kind. In a real editor this function would be more complex.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-test"><a class="header" href="#write-a-test">Write a test</a></h1>
<p>Let's write a test to see if what we wrote is working.</p>
<h3 id="run-tests-from-mainzig"><a class="header" href="#run-tests-from-mainzig">Run tests from main.zig</a></h3>
<p>To run this test with</p>
<pre><code>zig build test
</code></pre>
<p>we must add a section to our <code>main.zig</code> module:</p>
<div class="code-title">main.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Tests
//
///////////////////////////////////////////////////////////////////////////////

comptime {
    if (builtin.is_test) {
        _ = @import("Editor.zig");
    }
}
</code></pre>
<p>In fact, our <code>build.zig</code> is set up in a way that running <code>zig build test</code>
executes the tests that are in <code>main.zig</code>. When tests are executed from
a module, all tests placed in imported modules are executed too.</p>
<p>We don't want any test in <code>main.zig</code>, but with this <code>comptime</code> block we import
the modules we want to test, if <code>builtin.is_test</code> is true, and this happens
only when we're running tests.</p>
<p>Importing these modules will cause their tests to be executed, which is what we
want.</p>
<h3 id="add-the-test-in-editor"><a class="header" href="#add-the-test-in-editor">Add the test in Editor</a></h3>
<p>You should add some constants in <code>Editor</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const linux = @import("linux.zig");

const mem = std.mem;
const expect = std.testing.expect;
</code></pre>
<p>Then we add a test to <code>src/Editor.zig</code>. Add the test section just above the
Constants section.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Tests
//
///////////////////////////////////////////////////////////////////////////////

test "insert rows" {
    var da = std.heap.DebugAllocator(.{}){};
    defer _ = da.deinit();

    var e = try t.Editor.init(da.allocator(), .{ .rows = 50, .cols = 180 });
    try e.openFile("src/main.zig");
    defer e.deinit();

    const row = e.rowAt(6).chars.items;
    try expect(mem.eql(u8, "pub fn main() !void {", row));
}
</code></pre>
<p>It's a simple test that verifies the number of rows that have been read, and
that the content of one row actually matches the one in the file.</p>
<p>I initialize the editor with a 'fake' screen, because this isn't an interactive
terminal. Also, we avoid the event loop by reading directly the file with
<code>openFile()</code>, otherwise <code>processKeypress()</code> would hang the test.</p>
<p>If we modify <code>main.zig</code> again, this test could fail, or course. I will not, but
maybe you will.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-screen-surface"><a class="header" href="#the-screen-surface">The screen surface</a></h1>
<p>Now we're finally ready to start drawing on the screen.</p>
<p>We'll use an ArrayList to hold all characters that will be printed on every
screen refresh.</p>
<p>We'll add a new field to our Editor type:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// String that is printed on the terminal at every screen redraw
surface: t.Chars,
</code></pre>
<p>It is initialized in the <code>init()</code> function:</p>
<div class="code-title">Editor.zig: init()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    return .{
        .alc = allocator,
</code></pre>
</div>
<pre><code class="language-zig">    // multiply * 10, because each cell could contain escape sequences
    const surface_capacity = screen.rows * screen.cols * 10;
    return .{
        .alc = allocator,
        .surface = try t.Chars.initCapacity(allocator, surface_capacity),
</code></pre>
<p>We give our <code>surface</code> an initial capacity, so that it will probably never
reallocate. We make enough room for escape sequences: potentially, almost every
cell of the screen could contain an escape sequence.</p>
<p><code>surface</code> must be deinitialized in <code>deinit()</code>, or it will leak:</p>
<div class="code-title">Editor.zig: deinit()</div>
<div class="code-diff-added">
<pre><code class="language-zig">/// Deinitialize the editor.
pub fn deinit(e: *Editor) void {
    e.buffer.deinit();
</code></pre>
</div>
<pre><code class="language-zig">    e.surface.deinit(e.alc);
</code></pre>
<p>Note that we must pass the allocator as argument when deinitializing an
ArrayList.</p>
<h3 id="appending-to-the-surface"><a class="header" href="#appending-to-the-surface">Appending to the surface</a></h3>
<p>Every time we want to append to the surface, we'd need either:</p>
<pre class="code-block-small"><code class="language-zig">try e.surface.appendSlice(e.alc, slice);
</code></pre>
<p>or</p>
<pre class="code-block-small"><code class="language-zig">try e.surface.append(e.alc, character);
</code></pre>
<p>Let's create a helper function, because we'll append to the surface in lots
of places, and we want our code to be more concise and readable.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Append either a slice or a character to the editor surface.
fn toSurface(e: *Editor, value: anytype) !void {
    switch (@typeInfo(@TypeOf(value))) {
        .pointer =&gt; try e.surface.appendSlice(e.alc, value),
        else =&gt; try e.surface.append(e.alc, value),
    }
}
</code></pre>
<p>With this function we just need to do:</p>
<pre class="code-block-small"><code class="language-zig">try e.toSurface(slice_or_character);
</code></pre>
<div id="admonition-typeof" class="admonition admonish-note" role="note" aria-labelledby="admonition-typeof-title">
<div class="admonition-title">
<div id="admonition-typeof-title">
<p>@TypeOf</p>
</div>
<a class="admonition-anchor-link" href="draw/surface.html#admonition-typeof"></a>
</div>
<div>
<p>Builtin function <code>@TypeOf()</code> returns a type, which can only be evaluated at
compile time, hence our helper doesn't have any runtime cost, because the
operation to perform is decided at compile time. As proof of this, you will get
a compile error if you pass something wrong to this function.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-escape-sequences"><a class="header" href="#more-escape-sequences">More escape sequences</a></h1>
<p>We also add a bunch of constants to the bottom of <code>ansi.zig</code>. These are escape
sequences that we'll use while drawing, at one point or another, so let's just
add them all now:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Background color
pub const BgDefault = CSI ++ "40m";

/// Foreground color
pub const FgDefault = CSI ++ "39m";

/// Hide the terminal cursor
pub const HideCursor = CSI ++ "?25l";

/// Show the terminal cursor
pub const ShowCursor = CSI ++ "?25h";

/// Move cursor to position 1,1
pub const CursorTopLeft = CSI ++ "H";

/// Start reversing colors
pub const ReverseColors = CSI ++ "7m";

/// Reset colors to terminal default
pub const ResetColors = CSI ++ "m";

/// Clear the content of the line
pub const ClearLine = CSI ++ "K";

/// Color used for error messages
pub const ErrorColor = CSI ++ "91m";
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refresh-the-screen"><a class="header" href="#refresh-the-screen">Refresh the screen</a></h1>
<p>In <code>startUp()</code>, replace the commented placeholder in the event loop:</p>
<div class="code-title">Editor.zig: startUp()</div>
<pre><code class="language-zig">    while (e.should_quit == false) {
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">        // refresh the screen
</code></pre>
</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">        try e.refreshScreen();
</code></pre>
</div>
<p>We'll do the drawing with this function, that goes in a new section, which
I put above the Helpers section:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Screen update
//
///////////////////////////////////////////////////////////////////////////////

/// Full refresh of the screen.
fn refreshScreen(e: *Editor) !void {
    // code to come...
}
</code></pre>
<p>We'll have to explain what goes on.</p>
<ul>
<li>
<p>we clear our ArrayList, which will eventually contain the characters that
must be printed</p>
</li>
<li>
<p>we set the background color, hide the terminal cursor so that it doesn't get
in the way, and move the cursor to the top left position</p>
</li>
<li>
<p>we draw the rows, later we'll also draw the statusline and the message area</p>
</li>
</ul>
<div class="code-title">Editor.zig: refreshScreen()</div>
<pre><code class="language-zig">    e.surface.clearRetainingCapacity();

    try e.toSurface(ansi.BgDefault);
    try e.toSurface(ansi.HideCursor);
    try e.toSurface(ansi.CursorTopLeft);

    try e.drawRows();
    // try e.drawStatusline();
    // try e.drawMessageBar();
</code></pre>
<ul>
<li>
<p>we move the cursor to its current position and we show it again</p>
</li>
<li>
<p>we print the whole thing with a <code>write()</code> call</p>
</li>
</ul>
<div class="code-title">Editor.zig: refreshScreen()</div>
<pre><code class="language-zig">    const V = &amp;e.view;

    // move cursor to its current position (could have been moved with keys)
    var buf: [32]u8 = undefined;
    const row = V.cy - V.rowoff + 1;
    const col = V.rx - V.coloff + 1;
    try e.toSurface(try ansi.moveCursorTo(&amp;buf, row, col));
    try e.toSurface(ansi.ShowCursor);

    try linux.write(e.surface.items);
</code></pre>
<h3 id="movecursorto"><a class="header" href="#movecursorto"><code>moveCursorTo()</code></a></h3>
<p>To move the cursor we'll need a new function in <code>ansi.zig</code>:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Return the escape sequence to move the cursor to a position.
pub fn moveCursorTo(buf: []u8, row: usize, col: usize) ![]const u8 {
    return std.fmt.bufPrint(buf, CSI ++ "{};{}H", .{ row, col });
}
</code></pre>
<p>It takes a slice <code>buf</code> and formats it to generate an escape sequence that will
move the cursor to a position.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-the-rows"><a class="header" href="#drawing-the-rows">Drawing the rows</a></h1>
<p>This function will be expanded later, but for now all it needs to do is to draw
the rows without any highlight.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Append rows to be drawn to the surface. Handles escape sequences for syntax
/// highlighting.
fn drawRows(e: *Editor) !void {
    // code to come...
}
</code></pre>
<p>We can print a number of rows which is equal to the height of our main window,
which is <code>e.screen.rows</code>. We use a <code>for</code> loop with a range, but to the index
<code>y</code> we must add <code>e.view.rowoff</code>, which is the current row offset. This will be
greater than <code>0</code> if we scroll down our window and the first row went
off-screen.</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">    const V = &amp;e.view;
    const rows = e.buffer.rows.items;

    for (0 .. e.screen.rows) |y| {
        const ix: usize = y + V.rowoff;
</code></pre>
<p>Since we draw by screen rows, and not by Buffer rows, <code>y</code> may be greater than
the number of the Buffer rows, which means we are past the end of the file. In
this case we draw a <code>~</code> to point that out.</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">        // past buffer content
        if (ix &gt;= rows.len) {
            try e.toSurface('~');
        }
</code></pre>
<p>Otherwise, we are within the file content, but it doesn't mean that there is
something to print in all cases:</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">        // within buffer content
        else {
            // length of the rendered line
            const rowlen = rows[ix].render.len;

            // actual length that should be drawn because visible
            var len = if (V.coloff &gt; rowlen) 0 else rowlen - V.coloff;
</code></pre>
<p>For example, if we scrolled the window to the right, the leftmost columns would
go off-screen, and <code>e.view.coloff</code> would become positive. If the line is
shorter than that, nothing will be printed, because it's completely off-screen.</p>
<p>We also limit <code>len</code> to the number of screen columns:</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">            len = @min(len, e.screen.cols);
</code></pre>
<p>If <code>len &gt; 0</code> there's something to print: which would be the slice of the
rendered line that starts at <code>coloff</code>, and is long <code>len</code> characters.</p>
<p>We append this slice to the surface ArrayList.</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">            // draw the visible part of the row
            if (len &gt; 0) {
                try e.toSurface(rows[ix].render[V.coloff .. V.coloff + len]);
            }
        }
</code></pre>
<p>We end the line after that:</p>
<div class="code-title">Editor.zig: drawRows()</div>
<pre><code class="language-zig">        try e.toSurface(ansi.ClearLine);
        try e.toSurface("\r\n"); // end the line
    }
</code></pre>
<p>Again: <code>V.coloff</code> is <code>0</code> unless a part of the row went off-screen on the left
side.</p>
<p>At this point, if you compile and run:</p>
<pre><code>./kilo kilo
</code></pre>
<p>you should already be able to visualize the file on the screen! That's big
progress. You can't move the cursor, and you can still quit the editor with
<kbd>Ctrl-Q</kbd> pressed 3 times.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="draw/rows.html#admonition-note"></a>
</div>
<div>
<p>You will notice that the last 2 lines of the screen don't have the <code>~</code>
character: that's because in <code>init()</code> we subtracted 2 from the real screen
height, to make room for statusline and message area.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-statusline"><a class="header" href="#the-statusline">The statusline</a></h1>
<p>Uncomment the line in <code>refreshScreen()</code> where we draw the statusline.</p>
<div class="code-title">Editor.zig: refreshScreen()</div>
<pre><code class="language-zig">    try e.drawRows();
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">    // try e.drawStatusline();
</code></pre>
</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    try e.drawStatusline();
</code></pre>
</div>
<h3 id="the-drawstatusline-function"><a class="header" href="#the-drawstatusline-function">The <code>drawStatusline()</code> function</a></h3>
<p>I put this below <code>drawRows()</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Append the statusline to the surface.
fn drawStatusline(e: *Editor) !void {
    const V = &amp;e.view;
    // code to come...
}
</code></pre>
<p>We want the color of the statusline to be the inverse of the normal text color,
with dark text over bright background.
We want two sections, so we declare two buffers.</p>
<div class="code-title">Editor.zig: drawStatusline()</div>
<pre><code class="language-zig">    try e.toSurface(ansi.ReverseColors);

    var lbuf: [200]u8 = undefined;
    var rbuf: [80]u8 = undefined;
</code></pre>
<ul>
<li>
<p>on the <strong>left side</strong> we want to display the filename, or <code>[No Name]</code> for a newly
created file, and the <em>modified</em> state of the buffer</p>
</li>
<li>
<p>on the <strong>right side</strong>, the filetype (or <code>no ft</code>) and the current cursor position</p>
</li>
</ul>
<div class="code-title">Editor.zig: drawStatusline()</div>
<pre><code class="language-zig">    // left side of the statusline
    var ls = std.fmt.bufPrint(&amp;lbuf, "{s} - {} lines{s}", .{
        e.buffer.filename orelse "[No Name]",
        e.buffer.rows.items.len,
        if (e.buffer.dirty) " [modified]" else "",
    }) catch "";

    // right side of the statusline (leading space to guarantee separation)
    var rs = std.fmt.bufPrint(&amp;rbuf, " | {s} | col {}, ln {}/{} ", .{
        e.buffer.syntax orelse "no ft",
        V.cx + 1,
        V.cy + 1,
        e.buffer.rows.items.len,
    }) catch "";
</code></pre>
<p>We'll use <code>std.fmt.bufPrint</code> to format the two sides of the statusline, then
we'll fill with spaces the room between them, to cover the whole
<code>e.screen.cols</code> dimension, which would be the width of the screen.</p>
<p>Note that we use the <code>orelse</code> statement to provide fallbacks for our optional
variables (<code>e.buffer.filename</code> and <code>e.buffer.syntax</code>)</p>
<p>Since we'll use fixed buffers on the stack for <code>bufPrint</code>, there's the risk of
having filenames that are so long that they won't fit, in that case we just
print nothing. We do the same for the right side.</p>
<p>We'll prioritize the left side, in case there isn't enough room for both.</p>
<p>We'll have to ensure we reset colors and insert a new line at the end. We could
use a <code>defer</code> statement for this purpose, but inside <code>defer</code> statements error
handling isn't allowed, so we would have to ignore the errors, and hope for the
best. Instead we'll create a small helper function so that errors can still be
handled. In Zig the <code>goto</code> statement doesn't exist, so we must get used to this
kind of alternatives.</p>
<div class="code-title">Editor.zig: drawStatusline()</div>
<pre><code class="language-zig">    var room_left = e.screen.cols;

    // prioritize left side
    if (ls.len &gt; room_left) {
        ls = ls[0 .. room_left];
    }
    room_left -= ls.len;

    try e.toSurface(ls);

    if (room_left == 0) {
        try e.finalizeStatusline();
        return;
    }
</code></pre>
<details id="admonition-labeled-blocks-as-goto-alternative" class="admonition admonish-note" role="note" aria-labelledby="admonition-labeled-blocks-as-goto-alternative-title">
<summary class="admonition-title">
<div id="admonition-labeled-blocks-as-goto-alternative-title">
<p>Labeled blocks as goto alternative</p>
</div>
<a class="admonition-anchor-link" href="draw/statusline.html#admonition-labeled-blocks-as-goto-alternative"></a>
</summary>
<div>
<p>Another alternative to <code>goto</code> is a labeled block, for example:</p>
<pre class="code-block-small"><code class="language-zig">do: {
    std.debug.print("do block\n", .{});

    var i: usize = 0;
    while (i < 10) : (i += 1) {
        if (i == 5) {
            break :do;
        }
    }
    std.debug.print("no break\n", .{});
}
std.debug.print("exit\n", .{});
</code></pre>
<p>prints:</p>
<pre class="code-block-small"><code class="language-zig">do block
exit
</code></pre>
<p>This increases the indentation level of the whole block, though, so I prefer
other solutions, when possible.</p>
</div>
</details>
<p>To make sure we only append if there's enough room, we track the available room
in the <code>room_left</code> variable that is initially equal to <code>e.screen.cols</code>, and we
reduce it as we determine the size of the left and right sides</p>
<p>Append the right side and we're done:</p>
<div class="code-title">Editor.zig: drawStatusline()</div>
<pre><code class="language-zig">    // add right side and spaces if there is room left for them
    if (rs.len &gt; room_left) {
        rs = rs[0 .. room_left];
    }
    room_left -= rs.len;

    try e.surface.appendNTimes(e.alc, ' ', room_left);
    try e.toSurface(rs);
    try e.finalizeStatusline();
</code></pre>
<h3 id="finalizestatusline"><a class="header" href="#finalizestatusline"><code>finalizeStatusline()</code></a></h3>
<p>This is the helper function to finalize the statusline, and still be able to
handle errors.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Reset colors and append new line after statusline
fn finalizeStatusline(e: *Editor) !void {
    try e.toSurface(ansi.ResetColors);
    try e.toSurface("\r\n");
}
</code></pre>
<p>Compile and run, and enjoy your statusline!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-message-area"><a class="header" href="#the-message-area">The message area</a></h1>
<p>For the message area we'll need more Editor fields:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// String to be printed in the message area (can be a prompt)
status_msg: t.Chars,

/// Controls the visibility of the status message
status_msg_time: i64,
</code></pre>
<p>Also add these constants:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const time = std.time.timestamp;
const time_ms = std.time.milliTimestamp;

const initial_msg_size = 80;
</code></pre>
<p>Add to <code>init()</code>:</p>
<div class="code-title">Editor.zig: init()</div>
<pre><code class="language-zig">        .status_msg = try t.Chars.initCapacity(allocator, initial_msg_size),
        .status_msg_time = 0,
</code></pre>
<p>and to <code>deinit()</code> (always deinitialize ArrayLists or they will leak):</p>
<div class="code-title">Editor.zig: deinit()</div>
<pre><code class="language-zig">    e.status_msg.deinit(e.alc);
</code></pre>
<p>Uncomment the line in <code>refreshScreen()</code> where we draw the message area.</p>
<div class="code-title">Editor.zig: refreshScreen()</div>
<pre><code class="language-zig">    try e.drawRows();
    try e.drawStatusline();
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">    // try e.drawMessageBar();
</code></pre>
</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    try e.drawMessageBar();
</code></pre>
</div>
<h3 id="the-drawmessagebar-function"><a class="header" href="#the-drawmessagebar-function">The <code>drawMessageBar()</code> function</a></h3>
<p>I put this below <code>finalizeStatusline()</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Append the message bar to the surface.
fn drawMessageBar(e: *Editor) !void {
    try e.toSurface(ansi.ClearLine);

    var msglen = e.status_msg.items.len;
    if (msglen &gt; e.screen.cols) {
        msglen = e.screen.cols;
    }
    if (msglen &gt; 0 and time() - e.status_msg_time &lt; 5) {
        try e.toSurface(e.status_msg.items[0 .. msglen]);
    }
}
</code></pre>
<p>As you can see, it's pretty simple. We clear the line, then if there's
a message to be printed, we append it to the surface.</p>
<p>We have also some sort of timer: it's not a <em>real</em> timer in the sense that
there's not an async timer that runs independently from the main thread.
Remember that the screen is redrawn in the event loop, whose iterations are
controlled by the <code>processKeypress()</code> function, since it's that function that
halts the loop while waiting for new keys pressed by the user. So what this
"timer" does, is to check if 5 seconds have passed since the last redraw, then
it will append the message to the surface if it didn't, otherwise it will not
append anything, and the message won't be printed.</p>
<p>It will be the function which sets a status message that will update
<code>status_msg_time</code>, but we don't have a way to set a status message yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-welcome-message"><a class="header" href="#the-welcome-message">The welcome message</a></h1>
<p>The original <code>kilo</code> editor would print a welcome message when the program is
started without arguments, which results in a new empty, unnamed buffer to be
created.</p>
<p>We also want it because it's cool and reminds us (or at least me) of vim.</p>
<p>New fields in <code>Editor</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// String to be displayed when the editor is started without loading a file
welcome_msg: t.Chars,

/// Becomes false after the first screen redraw
just_started: bool,
</code></pre>
<p>Initialize in <code>init()</code>.</p>
<div class="code-title">Editor.zig: init()</div>
<pre><code class="language-zig">        .welcome_msg = try t.Chars.initCapacity(allocator, 0),
        .just_started = true,
</code></pre>
<p>Deinitialize in <code>deinit()</code>:</p>
<div class="code-title">Editor.zig: deinit()</div>
<pre><code class="language-zig">    e.welcome_msg.deinit(e.alc);
</code></pre>
<p>When, how, and where do we want the welcome message to appear?</p>
<ul>
<li>
<p>we generate it when the argument for <code>startUp()</code> is <code>null</code>, which means
there's no file to open</p>
</li>
<li>
<p>we want to generate it dynamically because the message should be centered on
screen, and we can assess that only at runtime</p>
</li>
<li>
<p>we render the message in <code>drawRows()</code></p>
</li>
</ul>
<h3 id="a-module-for-messages"><a class="header" href="#a-module-for-messages">A module for messages</a></h3>
<p>When generating the message, we must fetch the base string from somewhere.
It will be the same for other text constants and messages that we'll use in the
editor in the future. So we create a <code>message</code> module and we import it in
Editor:</p>
<pre><code class="language-zig">const message = @import("message.zig");
</code></pre>
<p>This module for now will look like this:</p>
<div class="code-title">message.zig</div>
<pre><code class="language-zig">//! Module that holds various strings for the message area, either status or
//! error messages, or prompts.

const std = @import("std");
const opt = @import("option.zig");

const status_messages = .{
    .{ "welcome", "Kilo editor -- version " ++ opt.version_str },
};

pub const status = std.StaticStringMap([]const u8).initComptime(status_messages);
</code></pre>
<p>We also create a <code>version_str</code> in our <code>option</code> module, so that it contains the
current version number, as a string:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">pub const version_str = "0.1";
</code></pre>
<p>The <code>StaticStringMap</code> is created at compile time (see how it's initialized),
and will be accessed in Editor with <code>message.status.get()</code>, that returns an
<em>optional value</em> which is <code>null</code> if the <em>key</em> couldn't be found.</p>
<p><em>Keys</em> of <code>StaticStringMap</code> will always be strings, but <em>values</em> can be of any
type. In our case they are also strings (<code>[]const u8</code>).</p>
<h3 id="generate-the-message"><a class="header" href="#generate-the-message">Generate the message</a></h3>
<p>We had a commented placeholder in <code>startUp()</code>, so we must replace it with the
actual function call.</p>
<div class="code-title">Editor.zig: startUp()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    else {
        // we generate the welcome message
    }
</code></pre>
</div>
<pre><code class="language-zig">    else {
        try e.generateWelcome();
    }
</code></pre>
<p>The function to generate the message is:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Generate the welcome message.
fn generateWelcome(e: *Editor) !void {
    // code to come...
}
</code></pre>
<p>The line with the welcome message starts with a <code>~</code>, because we're in an empty
buffer.</p>
<p>The length of the message must be limited to the screen columns - 1, because of
the <code>~</code> which we just appended.</p>
<div class="code-title">Editor.zig: generateWelcome()</div>
<pre><code class="language-zig">    try e.welcome_msg.append(e.alc, '~');

    var msg = message.status.get("welcome").?;
    if (msg.len &gt;= e.screen.cols) {
        msg = msg[0 .. e.screen.cols - 1];
    }
</code></pre>
<p>The padding will be inserted before the message.</p>
<div class="code-title">Editor.zig: generateWelcome()</div>
<pre><code class="language-zig">    const padding: usize = (e.screen.cols - msg.len) / 2;

    try e.welcome_msg.appendNTimes(e.alc, ' ', padding);
    try e.welcome_msg.appendSlice(e.alc, msg);
</code></pre>
<h3 id="render-the-message"><a class="header" href="#render-the-message">Render the message</a></h3>
<p>In <code>drawRows()</code>, all we have to do is replace the <code>if</code> branch for when the row
is past the end of the buffer, with this:</p>
<div class="code-title">Editor.zig: drawRows()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">        // past buffer content
        if (ix &gt;= rows.len) {
            try e.toSurface('~');
</code></pre>
</div>
<pre><code class="language-zig">        // past buffer content
        if (ix &gt;= rows.len) {
            if (e.just_started
                and e.buffer.filename == null
                and e.buffer.rows.items.len == 0
                and y == e.screen.rows / 3) {
                try e.toSurface(e.welcome_msg.items);
            }
            else {
                try e.toSurface('~');
            }
</code></pre>
<p>We append it to the surface if the buffer is empty, doesn't even have a name,
and current row is at about 1/3 of the height of the screen.</p>
<p>Remember to set <code>just_started</code> to <code>false</code> at the bottom of <code>refreshScreen()</code>,
if you didn't already.</p>
<div class="code-title">Editor.zig: refreshScreen()</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    e.just_started = false;
</code></pre>
</div>
<pre><code class="language-zig">    try linux.write(e.surface.items);
</code></pre>
<p>We also set <code>just_started</code> to <code>false</code> so that our welcome message won't be
printed again.</p>
<p>Compile and run with</p>
<pre><code>./kilo
</code></pre>
<p>to see an empty buffer and the welcome message. You can try to run again with
a narrower terminal window, to verify that the message and the statusline are
displayed correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-text-viewer"><a class="header" href="#a-text-viewer">A text viewer</a></h1>
<p>Right now we're able to open a file and display it, but not being able to move
the cursor, keeps us stuck in the top-left corner of the screen.</p>
<p>Our <code>processKeypress()</code> must detect more keys, and we must bind these keys to
actions to perform.</p>
<p>We change our function to this:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Process a keypress: will wait indefinitely for readKey, which loops until
/// a key is actually pressed.
fn processKeypress(e: *Editor) !void {
    const k = try ansi.readKey();

    const static = struct {
        var q: u8 = opt.quit_times;
    };

    const B = &amp;e.buffer;

    switch (k) {
        .ctrl_q =&gt; {
            if (B.dirty and static.q &gt; 0) {
                static.q -= 1;
                return;
            }
            try ansi.clearScreen();
            e.should_quit = true;
        },
        else =&gt; {},
    }

    // reset quit counter for any keypress that isn't Ctrl-Q
    static.q = opt.quit_times;
}
</code></pre>
<h3 id="optquit_times"><a class="header" href="#optquit_times">opt.quit_times</a></h3>
<p>First thing, we want to remove that magic number and bind <code>static.q</code> to an
option, so in <code>option.zig</code> we'll add:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">pub const quit_times = 3;
</code></pre>
<p>and we replace <code>3</code> with <code>opt.quit_times</code>. And we only want to repeat
<kbd>Ctrl-Q</kbd> if the buffer has modified.</p>
<p>Next, we'll handle more keypresses.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before we deal with movements, we must complete our Row type.</p>
<h3 id="the-rxtocx-method"><a class="header" href="#the-rxtocx-method">The <code>rxToCx()</code> method</a></h3>
<p>This does the opposite of the <code>cxToRx()</code> method, that is, it finds the real
column for an index of the rendered row. It must still iterate the real row,
not the rendered one, because from the latter we just couldn't know what was
a <code>tab</code> and what a real <code>space</code> character. Therefore we iterate the real row
like in <code>cxToRx()</code>, we track both the rendered column and the current index in
the real row, and when the resulting rendered column is greater than the
requested column we return the current index in the real row.</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">/// Calculate the position of a rendered column in the real row.
pub fn rxToCx(row: *Row, rx: usize) usize {
    var cur_rx: usize = 0;
    var cx: usize = 0;
    while (cx &lt; row.chars.items.len) : (cx += 1) {
        if (row.chars.items[cx] == '\t') {
            cur_rx += (opt.tabstop - 1) - (cur_rx % opt.tabstop);
        }
        cur_rx += 1;

        if (cur_rx &gt; rx) {
            return cx;
        }
    }
    return cx;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-keypress-handling"><a class="header" href="#more-keypress-handling">More keypress handling</a></h1>
<p>Inside the switch that handles keypresses, we add a variable and more prongs:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">    const B = &amp;e.buffer;
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    const V = &amp;e.view;
</code></pre>
</div>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        .ctrl_d, .ctrl_u, .page_up, .page_down =&gt; {
            // by how many rows we'll jump
            const leap = e.screen.rows - 1;

            // place the cursor at the top of the window, then jump
            if (k == .ctrl_u or k == .page_up) {
                V.cy = V.rowoff;
                V.cy -= @min(V.cy, leap);
            }
            // place the cursor at the bottom of the window, then jump
            else {
                V.cy = V.rowoff + e.screen.rows - 1;
                V.cy = @min(V.cy + leap, B.rows.items.len);
            }
        },

        .home =&gt; {
            V.cx = 0;
        },

        .end =&gt; {
            // last row doesn't have characters!
            if (V.cy &lt; B.rows.items.len) {
                V.cx = B.rows.items[V.cy].clen();
            }
        },

        .left, .right =&gt; {
            e.moveCursorWithKey(k);
        },

        .up, .down =&gt; {
            e.moveCursorWithKey(k);
        },
</code></pre>
<p>I added comments so that what happens should be self-explanatory.</p>
<p>One of my favorite Zig features is how you can omit the enum type when using
their values, since the type of those values is known to be that type of enum.
It makes the code very expressive and avoids redundancy, without resorting to
macros or untyped constants. It also makes it easier to write this kind of
guides.</p>
<p>We see the a new function, <code>moveCursorWithKey()</code>, which we'll cover next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-with-keys"><a class="header" href="#move-with-keys">Move with keys</a></h1>
<p>This function will let us move the cursor with arrow keys. Also in this case
the code is self-explanatory.</p>
<p>With keys <kbd>Left</kbd> and <kbd>Right</kbd> we can also change row, if we
are respectively in the first or last column of the row.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Update the cursor position after a key has been pressed.
fn moveCursorWithKey(e: *Editor, key: t.Key) void {
    const V = &amp;e.view;
    const numrows = e.buffer.rows.items.len;

    switch (key) {
        .left =&gt; {
            if (V.cx != 0) { // not the first column
                V.cx -= 1;
            }
            else if (V.cy &gt; 0) { // move back to the previous row
                V.cy -= 1;
                V.cx = e.currentRow().clen();
            }
        },
        .right =&gt; {
            if (V.cy &lt; numrows) {
                if (V.cx &lt; e.currentRow().clen()) { // not the last column
                    V.cx += 1;
                }
                else { // move to the next row
                    V.cy += 1;
                    V.cx = 0;
                }
            }
        },
        .up =&gt; {
            if (V.cy != 0) {
                V.cy -= 1;
            }
        },
        .down =&gt; {
            if (V.cy &lt; numrows) {
                V.cy += 1;
            }
        },
        else =&gt; {},
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-the-wanted-column"><a class="header" href="#handling-the-wanted-column">Handling the wanted column</a></h1>
<p>When we move vertically, the cursor keeps its current column. That's pretty
obvious. But when it moves to a shorter line, if we don't keep track of the
previous value, it will keep moving along the shorter line, instead we want to
move along the same column from where we started. That is the <em>wanted column</em>,
and in our <code>View</code> type is the <code>cwant</code> field.</p>
<p>This variable should be:</p>
<ul>
<li>
<p>restored when moving vertically, either with arrow keys or by page</p>
</li>
<li>
<p>set to the current column when moving left or right, or to the beginning of
the line (<kbd>Home</kbd> key), or after typing/deleting something</p>
</li>
<li>
<p>when using the <kbd>End</kbd> key, it should be set to a special value that
means: always stick to the end of the line when moving vertically</p>
</li>
</ul>
<p>The special value we use is <code>std.math.maxInt(usize)</code>, which we store in
a constant:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const maxUsize = std.math.maxInt(usize);
</code></pre>
<h3 id="the-cwant-enum"><a class="header" href="#the-cwant-enum">The Cwant enum</a></h3>
<p>These different behaviors are listed in an <code>enum</code>, which will go in our <code>types</code>
module:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// Controls handling of the wanted column.
pub const Cwant = enum(u8) {
    /// To set cwant to a new value
    set,
    /// To restore current cwant, or to the last column if too big
    restore,
    /// To set cwant to maxUsize, which means 'always the last column'
    maxcol,
};
</code></pre>
<h3 id="the-docwant-function"><a class="header" href="#the-docwant-function">The <code>doCwant()</code> function</a></h3>
<p>Differently from the original <code>kilo</code> editor, here the <code>cwant</code> field will track
the <em>rendered</em> column, not the real one, which makes more sense in an editor.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              View operations
//
///////////////////////////////////////////////////////////////////////////////

/// Handle wanted column. `want` can be:
/// .set: set e.view.cwant to a new value
/// .maxcol: set to maxUsize, which means 'always the last column'
/// .restore: set current column to cwant, or to the last column if too big
fn doCwant(e: *Editor, want: t.Cwant) void {
    const V = &amp;e.view;
    const numrows = e.buffer.rows.items.len;

    switch (want) {
        // code to come...
    }
}
</code></pre>
<p>So when we set <code>cwant</code>, we assign it to the current column of the <em>rendered</em>
row.</p>
<p>If <code>want</code> is <code>.maxcol</code>, we set <code>cwant</code> to our special value.</p>
<div class="code-title">Editor.zig: doCwant()</div>
<pre><code class="language-zig">        .set =&gt; {
            V.cwant = if (V.cy &lt; numrows) e.currentRow().cxToRx(V.cx) else 0;
        },
        .maxcol =&gt; {
            V.cwant = maxUsize;
        },
</code></pre>
<p>When we restore it, since <code>cwant</code> is an index in the <em>rendered</em> row,
we use <code>rxToCx()</code> to find out the real column, to which <code>cx</code> must be set.</p>
<p>When we restore <code>cwant</code>, we'll check if we can actually restore it. If the
length of the current row is shorter, the cursor will be moved to the last
column.</p>
<p>If the value of <code>cwant</code> is our special value, the cursor will always be placed
in the last column, even if the starting line was shorter than the following
ones.</p>
<div class="code-title">Editor.zig: doCwant()</div>
<pre><code class="language-zig">        .restore =&gt; {
            if (V.cy == numrows) { // past end of file
                V.cx = 0;
            }
            else if (V.cwant == maxUsize) { // wants end of line
                V.cx = e.currentRow().clen();
            }
            else {
                const row = e.currentRow();
                const rowlen = row.clen();
                if (rowlen == 0) {
                    V.cx = 0;
                }
                else {
                    // cwant is an index of the rendered column, must convert
                    V.cx = row.rxToCx(V.cwant);
                    if (V.cx &gt; rowlen) {
                        V.cx = rowlen;
                    }
                }
            }
        },
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="viewer/cwant.html#admonition-note"></a>
</div>
<div>
<p>Here the <code>else</code> prong isn't needed, since we handle all members of the <code>enum</code>.</p>
</div>
</div>
<h3 id="calls-to-docwant"><a class="header" href="#calls-to-docwant">Calls to <code>doCwant()</code></a></h3>
<p>Where should the wanted column be handled? Right in the <code>processKeypress()</code>
function. You'll have to add calls to <code>doCwant()</code> as follows:</p>
<div class="code-title">Editor.zig: somewhere in processKeypress()</div>
<pre><code class="language-zig">            // after handling &lt;ctrl-d&gt;, &lt;ctrl-u&gt;, &lt;page-up&gt;, &lt;page-down&gt;
            e.doCwant(.restore);

            // after handling &lt;up&gt;, &lt;down&gt;
            e.doCwant(.restore);

            // after handling &lt;left&gt;, &lt;right&gt; and &lt;home&gt;
            e.doCwant(.set);

            // after handling &lt;end&gt;
            e.doCwant(.maxcol);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-the-view"><a class="header" href="#scroll-the-view">Scroll the view</a></h1>
<p>There's one more thing to write, before all this begins to actually work. Until
now, movement keys would set the row (<code>View.cy</code>) and the real column (<code>View.cx</code>).
But in our <code>refreshScreen()</code> function, the escape sequence that actually moves
the cursor to the new position will need <code>View.rx</code>, that is the column in the
rendered row.</p>
<p>This value will be set in another function, <code>scroll()</code>, which will be invoked
at the top of the <code>refreshScreen()</code> function. So place the call now:</p>
<div class="code-diff-added">
<pre><code class="language-zig">/// Full refresh of the screen.
fn refreshScreen(e: *Editor) !void {
</code></pre>
</div>
<pre><code class="language-zig">    e.scroll();
</code></pre>
<p>We must define another option:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">/// Minimal number of screen lines to keep above and below the cursor
pub var scroll_off: u8 = 2;
</code></pre>
<p>The actual <code>scroll()</code> function has 3 purposes:</p>
<ul>
<li>adapt the view to respect the <code>scroll_off</code> option</li>
<li>set the visual column (column in the rendered row)</li>
<li>set <code>View.rowoff</code> and <code>View.coloff</code>, which control the visible part of the
buffer relatively to the first row and the first column</li>
</ul>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Scroll the view, respecting scroll_off.
fn scroll(e: *Editor) void {
    const V = &amp;e.view;
    const numrows = e.buffer.rows.items.len;

    // handle scroll_off here...

    // update rendered column here...

    // update rowoff and coloff here...
}
</code></pre>
<h3 id="the-scroll_off-option"><a class="header" href="#the-scroll_off-option">the <code>scroll_off</code> option</a></h3>
<p>This is how the Vim documentation describes it:</p>
<p><em>Minimal number of screen lines to keep above and below the cursor.
This will make some context visible around where you are working.</em></p>
<pre><code class="language-zig">    //////////////////////////////////////////
    //          scrolloff option
    //////////////////////////////////////////

    if (opt.scroll_off &gt; 0 and numrows &gt; e.screen.rows) {
        while (V.rowoff + e.screen.rows &lt; numrows
               and V.cy + opt.scroll_off &gt;= e.screen.rows + V.rowoff)
        {
            V.rowoff += 1;
        }
        while (V.rowoff &gt; 0 and V.rowoff + opt.scroll_off &gt; V.cy) {
            V.rowoff -= 1;
        }
    }
</code></pre>
<h3 id="the-rendered-column"><a class="header" href="#the-rendered-column">The rendered column</a></h3>
<pre><code class="language-zig">    //////////////////////////////////////////
    //          update rendered column
    //////////////////////////////////////////

    V.rx = 0;

    if (V.cy &lt; numrows) {
        V.rx = e.currentRow().cxToRx(V.cx);
    }
</code></pre>
<p>We just use the <code>cxToRx()</code> function, for all lines except the last one, which
is completely empty, not even a <code>\n</code> character, so we can't index it in any
way (the program would panic).</p>
<h3 id="rowoff-coloff"><a class="header" href="#rowoff-coloff"><code>rowoff</code>, <code>coloff</code></a></h3>
<p><code>rowoff</code> is the topmost visible row, <code>coloff</code> is the leftmost visible column.
While the latter is rarely positive, the former will be positive whenever we
can't see the first line of the file.</p>
<p>When the function is called, <code>cy</code> (the cursor column) can have a new value, but
<code>rowoff</code> has still the old value, so it must be updated. Same for <code>coloff</code>.</p>
<pre><code class="language-zig">    //////////////////////////////////////////
    //      update rowoff and coloff
    //////////////////////////////////////////

    // cursor has moved above the visible window
    if (V.cy &lt; V.rowoff) {
        V.rowoff = V.cy;
    }
    // cursor has moved below the visible window
    if (V.cy &gt;= V.rowoff + e.screen.rows) {
        V.rowoff = V.cy - e.screen.rows + 1;
    }
    // cursor has moved beyond the left edge of the window
    if (V.rx &lt; V.coloff) {
        V.coloff = V.rx;
    }
    // cursor has moved beyond the right edge of the window
    if (V.rx &gt;= V.coloff + e.screen.cols) {
        V.coloff = V.rx - e.screen.cols + 1;
    }
</code></pre>
<details id="admonition-casting-numbers" class="admonition admonish-tip" role="note" aria-labelledby="admonition-casting-numbers-title">
<summary class="admonition-title">
<div id="admonition-casting-numbers-title">
<p>Casting numbers</p>
</div>
<a class="admonition-anchor-link" href="viewer/scroll.html#admonition-casting-numbers"></a>
</summary>
<div>
<p>When calculating a value, and we are handling <strong>unsigned</strong> integer types (like
in this case), we should avoid subtractions, unless we are <strong>absolutely</strong> sure
that the left operand is greater than the right operand.</p>
<p>Castings in Zig tend to be quite verbose, since the Zig phylosophy is to make
everything as explicit as possible, and the verbosity is also an element of the
concept of <em>friction</em> that Zig has adopted: to make safe things easy, and
unsafe things uncomfortable, even if not impossible, so that one becomes
inclined to take the safer route to the solution of a problem.</p>
<p>In this program, we don't do any casting, but we don't have to deal with
floating point numbers either.</p>
<p>To avoid castings of unsigned integers, sometimes it's enough to move the
subtracted operand to the other side of the equation, making it become
a positive operand. It's what we're doing here, even though it can make the
operation less intuitive.</p>
<p>This <a href="https://ziggit.dev/t/short-math-notation-casting-clarity-of-math-expressions/10008">thread on Ziggit
forum</a>
is an interesting read about castings.</p>
</div>
</details>
<h3 id="compile-and-run"><a class="header" href="#compile-and-run">Compile and run!</a></h3>
<p>Our text viewer is complete. You should be able to open any file and navigate
it with ease.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-text-editor"><a class="header" href="#a-text-editor">A text editor</a></h1>
<p>Now we want to turn our text viewer in a proper editor. I guess it's the
natural progression for this kind of things. Not to mention that our guide is
called "<em>Build a text</em> <em><strong>editor</strong></em>", not "<em>Build a text</em> <em><strong>viewer</strong></em>". Let's
not forget that.</p>
<p>Let's start by handling more keypresses in the <code>processKeypress()</code> function.</p>
<p>We add new switch prongs for <kbd>Backspace</kbd>, <kbd>Del</kbd> and
<kbd>Enter</kbd>:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        .backspace, .ctrl_h, .del =&gt; {
            if (k == .del) {
                e.moveCursorWithKey(.right);
            }
            try e.deleteChar();
            e.doCwant(.set);
        },

        .enter =&gt; try e.insertNewLine(),
</code></pre>
<p>We also change our <code>else</code> branch to handle characters to be inserted. We only
handle <kbd>Tab</kbd> and printable characters, for now.</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        else =&gt; {
            const c = @intFromEnum(k);
            if (k == .tab or asc.isPrint(c)) {
                try e.insertChar(c);
                e.doCwant(.set);
            }
        },
</code></pre>
<p>There is a new constant to set:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const asc = std.ascii;
</code></pre>
<p>And new functions to implement:</p>
<ul>
<li><code>insertChar</code> will insert a character at cursor positin</li>
<li><code>deleteChar</code> will delete the character on the left of the cursor</li>
<li><code>insertNewLine</code> will start editing a new line after the current one</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert-characters"><a class="header" href="#insert-characters">Insert characters</a></h1>
<p>Before inserting a character, we check if we are in a new row, if so, we insert
the row in the buffer. After that, we can just insert the character and move
forward. We wrote already our <code>insertRow()</code> function, so there's nothing to add
(for now).</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              In-row operations
//
///////////////////////////////////////////////////////////////////////////////

/// Insert a character at current cursor position. Handle textwidth.
fn insertChar(e: *Editor, c: u8) !void {
    const V = &amp;e.view;

    // last row, insert a new row before inserting the character
    if (V.cy == e.buffer.rows.items.len) {
        try e.insertRow(e.buffer.rows.items.len, "");
    }

    // insert the character and move the cursor forward
    try e.rowInsertChar(V.cy, V.cx, c);
    V.cx += 1;
}
</code></pre>
<h3 id="rowinsertchar"><a class="header" href="#rowinsertchar"><code>rowInsertChar()</code></a></h3>
<p>This will perform the actual character insertion in the <code>row.chars</code> ArrayList,
update the rendered row, and set the <em>modified</em> flag.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Insert character `c` in the row with index `ix`, at column `at`.
fn rowInsertChar(e: *Editor, ix: usize, at: usize, c: u8) !void {
    try e.rowAt(ix).chars.insert(e.buffer.alc, at, c);
    try e.updateRow(ix);
    e.buffer.dirty = true;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deleting-a-character"><a class="header" href="#deleting-a-character">Deleting a character</a></h1>
<p>By deleting a character, we mean deleting the character to the left of our
cursor, what the <kbd>Backspace</kbd> key normally does.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Delete a character before cursor position (backspace).
fn deleteChar(e: *Editor) !void {
    const V = &amp;e.view;
    const B = &amp;e.buffer;

    // code to come...
}
</code></pre>
<p>We'll want to handle different cases:</p>
<p><strong>Cursor is past the end of file</strong>: move to the end of the previous line, don't
return, we will possibly delete a character.</p>
<pre><code class="language-zig">    // past the end of the file
    if (V.cy == B.rows.items.len) {
        e.moveCursorWithKey(.left);
    }
</code></pre>
<p><strong>Cursor at the start of the file</strong>: nothing to do.</p>
<pre><code class="language-zig">    // start of file
    if (V.cx == 0 and V.cy == 0) {
        return;
    }
</code></pre>
<p><strong>Cursor after the first column</strong>: delete the character at column before the
current one.</p>
<pre><code class="language-zig">    // delete character in current line
    if (V.cx &gt; 0) {
        try e.rowDelChar(V.cy, V.cx - 1);
        V.cx -= 1;
    }
</code></pre>
<p><strong>Cursor is at the start of a line which isn't the first one</strong>: we'll append the
current line to the previous one, then delete the current row. The cursor will
then be moved to the row above, at a column that is the length of the previous
row before the lines were joined.</p>
<pre><code class="language-zig">    // join with previous line
    else {
        V.cx = B.rows.items[V.cy - 1].clen();
        try e.rowInsertString(V.cy - 1, V.cx, e.currentRow().chars.items);
        e.deleteRow(V.cy);
        V.cy -= 1;
    }
</code></pre>
<h3 id="rowdelchar"><a class="header" href="#rowdelchar"><code>rowDelChar()</code></a></h3>
<p>For the actual character deletion we write <code>rowDelChar()</code>, which closely
resembles <code>rowInsertChar()</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Delete a character in the row with index `ix`, at column `at`.
fn rowDelChar(e: *Editor, ix: usize, at: usize) !void {
    _ = e.rowAt(ix).chars.orderedRemove(at);
    try e.updateRow(ix);
    e.buffer.dirty = true;
}
</code></pre>
<h3 id="rowinsertstring"><a class="header" href="#rowinsertstring"><code>rowInsertString()</code></a></h3>
<p>In case we want to join lines, we'll need two new functions.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Insert a string at position `at`, in the row at index `ix`.
fn rowInsertString(e: *Editor, ix: usize, at: usize, chars: []const u8) !void {
    try e.rowAt(ix).chars.insertSlice(e.buffer.alc, at, chars);
    try e.updateRow(ix);
    e.buffer.dirty = true;
}
</code></pre>
<p>This is very similar to <code>rowInsertChar()</code>, but inserts a slice instead of
inserting a character. Here we're just appending at the end of the row, since
we're passing an <code>at</code> argument that is equal to the length of the row.</p>
<h3 id="deleterow"><a class="header" href="#deleterow"><code>deleteRow()</code></a></h3>
<p>The last function we need for now is the one that deletes a row from the
Buffer. I put this function below <code>insertRow()</code>.</p>
<p>As mentioned when we talked about the Buffer type, we're sometimes
deinitializing individual rows in the Editor methods, which isn't ideal, but
I don't think that creating a method in Buffer just for this is that much
better. We can access the Buffer allocator just fine, but we must remember that
a Row uses the Buffer allocator, not the Editor one. It's only <em>happening</em>
right now that both Editor and Buffer use the same allocator, but things might
change in the future.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Delete a row and deinitialize it.
fn deleteRow(e: *Editor, ix: usize) void {
    var row = e.buffer.rows.orderedRemove(ix);
    row.deinit(e.buffer.alc);
    e.buffer.dirty = true;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-string-module"><a class="header" href="#the-string-module">The string module</a></h1>
<p>Before we proceed, let's add a new module called <code>string.zig</code>. It will be quite
simple, just a few helpers for string operations.</p>
<p>It will contain a single function for now. Don't forget to import in Editor.</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">//! Module with functions handling strings.

///////////////////////////////////////////////////////////////////////////////
//
//                              Functions
//
///////////////////////////////////////////////////////////////////////////////

/// Return the number of leading whitespace characters
pub fn leadingWhitespaces(src: []u8) usize {
    var i: usize = 0;
    while (i &lt; src.len and asc.isWhitespace(src[i])) : (i += 1) {}
    return i;
}

///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const asc = std.ascii;
const mem = std.mem;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert-a-new-line"><a class="header" href="#insert-a-new-line">Insert a new line</a></h1>
<p>We insert a new line when we press <kbd>Enter</kbd>. Nothing simpler right?
This operation is a bit more complex than it seems, especially if we want to
copy indentation, which is optional, but it's so useful that we don't want to
miss it.</p>
<p>Let's ignore indentation for now, and write the basic function.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Insert lines
//
///////////////////////////////////////////////////////////////////////////////

/// Insert a new line at cursor position. Will carry to the next line
/// everything that is after the cursor.
fn insertNewLine(e: *Editor) !void {
    const V = &amp;e.view;

    // make sure the beginning of the line is visible
    V.coloff = 0;

    // code to come...

    // row operations have been concluded, update rows
    try e.updateRow(V.cy - 1);
    try e.updateRow(V.cy);

    // set cursor position at the start of the new line
    V.cx = 0;
    V.cwant = 0;
}
</code></pre>
<p>At least, we want to handle several cases:</p>
<ul>
<li>are we at the beginning of the line (<code>cx = 0</code>)? We insert an empty line
above the current line, then increase the row number</li>
</ul>
<div class="code-title">Editor.zig: insertNewLine()</div>
<pre><code class="language-zig">    // at first column, just insert an empty line above the cursor
    if (V.cx == 0) {
        try e.insertRow(V.cy, "");
        V.cy += 1;
        return;
    }
</code></pre>
<ul>
<li>is there any whitespace that follows the cursor? Then we want to remove it
when carrying over the text that follows</li>
</ul>
<div class="code-title">Editor.zig: insertNewLine()</div>
<pre><code class="language-zig">    // leading whitespace removed from characters after cursor
    var skipw: usize = 0;

    var oldrow = e.currentRow().chars.items;

    // any whitespace before the text that is going into the new row
    if (V.cx &lt; oldrow.len) {
        skipw = str.leadingWhitespaces(oldrow[V.cx..]);
    }
</code></pre>
<p>We already know that we are in the middle of a line, so we must carry
everything that comes after the cursor to the new line.</p>
<p>After the row has been inserted, we proceed to the new row and shrink the row
above. We perform this operation last, because we needed those characters to be
able to append them. <em>Cut and paste</em> is actually a <em>copy then delete</em> operation
in our case.</p>
<div class="code-title">Editor.zig: insertNewLine()</div>
<pre><code class="language-zig">    // will insert a row with the characters to the right of the cursor
    // skipping whitespace after the cursor
    try e.insertRow(V.cy + 1, oldrow[V.cx + skipw ..]);

    // proceed to the new row
    V.cy += 1;

    // delete from the row above the content that we moved to the next row
    e.rowAt(V.cy - 1).chars.shrinkAndFree(e.alc, V.cx);
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="editor/newline.html#admonition-note"></a>
</div>
<div>
<p>We are using the <code>shrinkAndFree</code> method, which is not optimal, because in many
cases we would like to retain the ArrayList capacity. At least partially.</p>
<p>We could use instead the method <code>shrinkRetainingCapacity</code>, which does what it
says. But this could lead to excessive memory usage, because rows would always
keep the biggest capacity they had at any time, always growing, never
shrinking.</p>
<p>Maybe better would be to do a <code>shrinkAndFree</code> while keeping some
extra room, followed by a <code>resize</code> to set the correct length.</p>
<p>The same concepts would apply to <code>row.render</code>, if it was made an ArrayList.</p>
<p>These are all optimizations that can wait, anyway. For now, we keep it simple.</p>
</div>
</div>
<p>You might want to compile and run at this point, to check that everything is
working. You should be able to insert characters, delete them, and inserting
new lines.</p>
<h3 id="autoindent"><a class="header" href="#autoindent">Autoindent</a></h3>
<p>We also want an option for <em>autoindent</em>.</p>
<p>Let's add the option:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">/// Copy indent from current line when starting a new line
pub var autoindent = true;
</code></pre>
<p>Autoindent brings additional concerns:</p>
<ul>
<li>
<p>we should copy the indent from the line above</p>
</li>
<li>
<p>are we inserting the line while in the middle of the indent? Then we want to
shorten the indent and remove the part of it that lies after the cursor</p>
</li>
</ul>
<p>Add the <code>ind</code> variable: it is the number of whitespace characters that we must
copy from the line above.</p>
<div class="code-diff-added">
<pre><code class="language-zig">    // leading whitespace removed from characters after cursor
    var skipw: usize = 0;
</code></pre>
</div>
<pre><code class="language-zig">    // extra characters for indent
    var ind: usize = 0;
</code></pre>
<p>What if we hit <kbd>Enter</kbd> in the middle of the indentation? We want to
reduce it to the current column.</p>
<div class="code-diff-added">
<pre><code class="language-zig">    // any whitespace before the text that is going into the new row
    if (V.cx &lt; oldrow.len) {
        skipw = str.leadingWhitespaces(oldrow[V.cx..]);
    }
</code></pre>
</div>
<pre><code class="language-zig">    if (opt.autoindent) {
        ind = str.leadingWhitespaces(oldrow);

        // reduce indent if current column is within it
        if (V.cx &lt; ind) {
            ind = V.cx;
        }
    }
</code></pre>
<p>After we proceed to the new row, we must copy over the indent from the line
above. Before copying, we reassign the pointer, because a row insertion in
<code>Buffer.rows</code> has happened, which could have caused the invalidation of all row
pointers...</p>
<div class="code-diff-added">
<pre><code class="language-zig">    // proceed to the new row
    V.cy += 1;
</code></pre>
</div>
<pre><code class="language-zig">    if (ind &gt; 0) {
        // reassign pointer, invalidated by row insertion
        oldrow = e.rowAt(V.cy - 1).chars.items;

        // in new row, shift the old content forward, to make room for indent
        const newrow = try e.currentRow().chars.addManyAt(e.alc, 0, ind);

        // Copy the indent from the previous row.
        for (0..ind) |i| {
            newrow[i] = oldrow[i];
        }
    }
</code></pre>
<p>Finally, we must update the last two lines to set the cursor column after the
indent:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    // set cursor position at the start of the new line
    V.cx = 0;
    V.cwant = 0;
</code></pre>
</div>
<pre><code class="language-zig">    // set cursor position right after the indent in the new line
    V.cx = ind;
    V.cwant = ind;
</code></pre>
<p>Compile and try it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-text-wrapping"><a class="header" href="#handling-text-wrapping">Handling text wrapping</a></h1>
<p>There's one last thing that we should handle, one little thing that will make
our editor much more usable.</p>
<p>After we type a certain number of characters in the line, we want our text to
be automatically wrapped into a new line, to avoid that the line becomes too
long.</p>
<p>We call this option <code>textwidth</code> and we add it to our <code>option</code> module.</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">/// Wrap text over a new line, when current line becomes longer than this value
pub var textwidth = struct {
    enabled: bool = true,
    len: u8 = 79,
} {};
</code></pre>
<p>Thinking more about it, it's not always desirable, especially when writing
code. Our implementation will be particularly stubborn and absolutely refuse to
let us write differently. In the future we might introduce ways to change
option values with key combinations, and allow different options for different
filetypes. For now, this is it, and we must accept it.</p>
<p>We need a new <code>string</code> module function:</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">/// Return true if `c` is a word character.
pub fn isWord(c: u8) bool {
    return switch (c) {
        '0'...'9', 'a'...'z', 'A'...'Z', '_' =&gt; true,
        else =&gt; false,
    };
}
</code></pre>
<p>Handling of text wrapping happens in <code>insertChar()</code>, right after inserting the
character.</p>
<div class="code-title">Editor.zig: insertChar()</div>
<pre><code class="language-zig">    // insert the character and move the cursor forward
    try e.rowInsertChar(V.cy, V.cx, c);
    V.cx += 1;
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    //////////////////////////////////////////
    //              textwidth
    //////////////////////////////////////////

    const row = e.currentRow();
    const rx = row.cxToRx(V.cx);

    if (opt.textwidth.enabled and rx &gt; opt.textwidth.len and str.isWord(c)) {
</code></pre>
</div>
<p>The logic can be split in two phases.</p>
<h3 id="phase-1"><a class="header" href="#phase-1">Phase 1</a></h3>
<div class="numbered-table">
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>•</td><td>we must find the start of the current word, crawling back along the current row</td></tr>
<tr><td>•</td><td>if this word is preceded by a space character, we push back the cursor again, because we want to remove a single space while wrapping text, but not more than one</td></tr>
<tr><td>•</td><td>if this word is preceded by another kind of separator, we don't remove it, we just wrap the word</td></tr>
</tbody></table>
</div><div class="code-title">Editor.zig: insertChar()</div>
<pre><code class="language-zig">        // will be 1 if a space before the wrapped word must be removed
        var skipw: usize = 0;

        // find the start of the current word
        var start: usize = rx - 1;

        while (start &gt; 0) {
            if (!str.isWord(row.render[start - 1])) {
                // we want to remove a space before the wrapped word, but not
                // other kinds of separators (not even a tab, just in case)
                if (row.render[start - 1] == ' ') {
                    skipw = 1;
                }
                break;
            }
            start -= 1;
        }
</code></pre>
<h3 id="phase-2"><a class="header" href="#phase-2">Phase 2</a></h3>
<p>We crawled back in the row, and we found where this word began. If the column
is 0, it means it's a single very long sequence of <em>word</em> characters, we can't
wrap anything.</p>
<p>If instead we can wrap it, we proceed as follows:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>•</td><td>we set the cursor before the word, and also before the space character that precedes it (if there is one)</td></tr>
<tr><td>•</td><td>we insert a new line: the same things that would happen when pressing <kbd>Enter</kbd> would happen now, the extra space would be deleted and the word would be carried to the new line</td></tr>
<tr><td>•</td><td>we move forward the cursor to the end of the word we wrapped</td></tr>
</tbody></table>
</div><div class="code-title">Editor.zig: insertChar()</div>
<pre><code class="language-zig">        // only wrap if the word doesn't start at the beginning
        if (start &gt; 0) {
            const wlen = rx - start;

            // move the cursor to the start of the word, also skipping a space
            V.cx = row.rxToCx(start - skipw);

            // new line insertion will carry over the word and delete the space
            try e.insertNewLine();

            // move forward the cursor to the end of the word
            V.cx += wlen;
        }
    }
</code></pre>
<p>This completes the <em>editor</em> chapter. We still can't save our edits, but before
getting there we need to expand the capabilities of our message area, so that
it can actually print something.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-the-user"><a class="header" href="#interacting-with-the-user">Interacting with the user</a></h1>
<p>At various points of our program, we'll want to interact with the users, either
by notifying them of something, or by requesting something.</p>
<p>For example, we want to print a "help" sort of message when the editor starts,
we must prompt for a filename when trying to save an unnamed buffer, or for
a word when using the searching functionality.</p>
<p>We have already added the <code>status_msg</code> field in Editor, so we must add
a function that prints it.</p>
<p>We'll have two ways to print, either normal messages (or prompts) using regular
highlight, or <em>error</em> messages, which we'll print in a bright red color.</p>
<h3 id="statusmessage"><a class="header" href="#statusmessage"><code>statusMessage()</code></a></h3>
<p>What this function does, is clearing the previous content, and replace it with
a new one, which we'll format on the fly by using the <code>ArrayList(u8)</code> method
<code>print()</code>. Note that this method only works if the base type of the array is
<code>u8</code>.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Message area
//
///////////////////////////////////////////////////////////////////////////////

/// Set a status message, using regular highlight.
pub fn statusMessage(e: *Editor, comptime format: []const u8, args: anytype) !void {
    assert(format.len &gt; 0);
    e.status_msg.clearRetainingCapacity();
    try e.status_msg.print(e.alc, format, args);
    e.status_msg_time = time();
}
</code></pre>
<p><code>print()</code> uses <code>std.Io.Writer</code>, we'll see this interface again when we'll want
to save a file.</p>
<p>We never pass an empty format, so we <code>assert()</code> that the format is not empty.
You have to define a <code>assert</code> constant (do it yourself).</p>
<p>Finally we update <code>status_msg_time</code>, so that the message will be actually
printed, then cleared after a while.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="message/index.html#admonition-note"></a>
</div>
<div>
<p>This function doesn't really <em>print</em> anything on screen: the actual printing
will be done in <code>drawMessageBar()</code>, which we already wrote.</p>
</div>
</div>
<p>Compile and run to see your "help" message printed in the message area when you
start up the editor.</p>
<h3 id="errormessage"><a class="header" href="#errormessage"><code>errorMessage()</code></a></h3>
<p>This function is similar, but it will color the message in bright red, since
it's supposed to be an error. Note that we can use the <code>++</code> string
concatenation operator, since all values are comptime-known.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Print an error message, using error highlight.
pub fn errorMessage(e: *Editor, comptime format: []const u8, args: anytype) !void {
    assert(format.len &gt; 0);
    e.status_msg.clearRetainingCapacity();
    const fmt = ansi.ErrorColor ++ format ++ ansi.ResetColors;
    try e.status_msg.print(e.alc, fmt, args);
    e.status_msg_time = time();
}
</code></pre>
<h3 id="the-help-message"><a class="header" href="#the-help-message">The 'help' message</a></h3>
<p>Let's take care of the "help" message.</p>
<div class="code-title">Editor.zig: startUp()</div>
<pre><code class="language-zig">pub fn startUp(e: *Editor, path: ?[]const u8) !void {
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    try e.statusMessage(message.status.get("help").?, .{});
</code></pre>
</div>
<p><code>help</code> should be a <em>key</em> in our message string map, but we don't have it yet,
so add it to <code>status_messages</code>:</p>
<div class="code-title">message.zig: status_messages</div>
<pre><code class="language-zig">    .{ "help", "HELP: Ctrl-S = save | Ctrl-Q = quit | Ctrl-F = find" },
</code></pre>
<h3 id="the-unsaved-message"><a class="header" href="#the-unsaved-message">The 'unsaved' message</a></h3>
<p>Let's add a message that warns us when we press <kbd>Ctrl-Q</kbd> and there are
unsaved changes:</p>
<div class="code-title">message.zig: status_messages</div>
<pre><code class="language-zig">    .{ "unsaved", "WARNING!!! File has unsaved changes. Press Ctrl-Q {d} more times to quit." },
</code></pre>
<p>We print this message in <code>processKeypress</code>:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        .ctrl_q =&gt; {
            if (B.dirty and static.q &gt; 0) {
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">                try e.statusMessage(message.status.get("unsaved").?, .{static.q});
</code></pre>
</div>
<p>Now, if we have unsaved changes, we'll get this warning, telling us how many
times we must press <kbd>Ctrl-Q</kbd> to quit.</p>
<h3 id="needed-constants"><a class="header" href="#needed-constants">Needed constants:</a></h3>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const assert = std.debug.assert;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-writing"><a class="header" href="#io-writing">I/O: writing</a></h1>
<p>To save files we'll use the <code>Io.Writer</code> interface. I'm not going to explain in
detail what is possible to do with it, because it has been recently introduced
into the Zig standard library, it's a vast subject and I'm not familiar with
it. So I'll stick to the minimum of informations to make our use case work.</p>
<p>Let's handle first the case where the filename is known, and we just want to
save the current file.</p>
<p>We add another <em>key-value pair</em> to our <code>status_messages</code> string map:</p>
<div class="code-title">message.zig: status_messages</div>
<pre><code class="language-zig">    .{ "bufwrite", "\"{s}\" {d} lines, {d} bytes written" },
</code></pre>
<p>So that we'll print a message if the save is successful.</p>
<h3 id="ioerr-and-the-error-messages-stringmap"><a class="header" href="#ioerr-and-the-error-messages-stringmap"><code>ioerr()</code> and the error messages StringMap</a></h3>
<p>Whenever a write operation fails, we'll handle the error in a helper function,
<code>ioerr()</code>:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Handle an error of type IoError by printing an error message, without
/// quitting the editor.
fn ioerr(e: *Editor, err: t.IoError) !void {
    try e.errorMessage(message.errors.get("ioerr").?, .{@errorName(err)});
    return;
}
</code></pre>
<p>As you can see, this function doesn't make the process terminate only because
we couldn't save the file for some reason. Instead, it will print an error in
the message area, with the name of the error.</p>
<h3 id="ioerror"><a class="header" href="#ioerror">IoError</a></h3>
<p>The <code>ioerr</code> function accepts an argument of type <code>IoError</code>. This is an error
union that we'll define in <code>types</code>:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Error sets
//
///////////////////////////////////////////////////////////////////////////////

/// Error set for both read and write operations.
pub const IoError = std.fs.File.OpenError
                 || std.fs.File.WriteError
                 || std.Io.Reader.Error
                 || std.Io.Writer.Error;
</code></pre>
<p>It includes errors for both reading and writing, because to write a file, we
must also be able to open it, and also that can fail.</p>
<h3 id="error-messages"><a class="header" href="#error-messages">Error messages</a></h3>
<p>We keep all these error messages we'll be using in <code>message.zig</code>, in another
StringMap that we'll call <code>errors</code>:</p>
<div class="code-title">message.zig</div>
<pre><code class="language-zig">const error_messages = .{
    .{ "ioerr", "Can't save! I/O error: {s}" },
};

pub const errors = std.StaticStringMap([]const u8).initComptime(error_messages);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-a-file"><a class="header" href="#saving-a-file">Saving a file</a></h1>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Try to save the current file, prompt for a file name if currently not set.
/// Currently saving the file fails if directory doesn't exist, and there is no
/// tilde expansion.
fn saveFile(e: *Editor) !void {
    var B = &amp;e.buffer;

    if (B.filename == null) {
        // will prompt for a filename
        return;
    }

    // code to come...
}
</code></pre>
<p>Before saving, we want to determine in advance how many bytes we'll write to
disk, so that we can print it in a message.</p>
<p>Since <code>e.buffer.filename</code> is optional, once we are certain that it can't be
<code>null</code>, we can access safely its non-null value with the <code>.?</code> notation.</p>
<div class="code-title">Editor.zig: saveFile()</div>
<pre><code class="language-zig">    // determine number of bytes to write, make room for \n characters
    var fsize: usize = B.rows.items.len;
    for (B.rows.items) |row| {
        fsize += row.chars.items.len;
    }

    const file = std.fs.cwd().createFile(B.filename.?, .{ .truncate = true });
    if (file) |f| {
        // write lines to file
    }
    else |err|{
        e.alc.free(B.filename.?);
        B.filename = null;
        return e.ioerr(err);
    }
</code></pre>
<p>We will try to open the file in writing mode, truncating it and replacing all
bytes. Here the key <em>std</em> function is <code>std.fs.cwd().createFile()</code>.</p>
<p>In this block we write the lines:</p>
<div class="code-title">Editor.zig: saveFile()</div>
<pre><code class="language-zig">    if (file) |f| {
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">        // write lines to file
</code></pre>
</div>
<pre><code class="language-zig">        var buf: [1024]u8 = undefined;
        var writer = f.writer(&amp;buf);
        defer f.close();
        // for each line, write the bytes, then the \n character
        for (B.rows.items) |row| {
            writer.interface.writeAll(row.chars.items) catch |err| return e.ioerr(err);
            writer.interface.writeByte('\n') catch |err| return e.ioerr(err);
        }
        // write what's left in the buffer
        try writer.interface.flush();
        try e.statusMessage(message.status.get("bufwrite").?, .{
            B.filename.?, B.rows.items.len, fsize
        });
        B.dirty = false;
        return;
</code></pre>
<p>Before writing, we need a buffered writer. The size doesn't matter too much
I think, but too small would be close to unbuffered.</p>
<p>To actually write the file, we use the <code>Io.Writer</code> interface, which is accessed
at <code>writer.interface</code>.</p>
<p>After we wrote all bytes, we have to <em>flush</em> the writer. This is what happens:</p>
<div class="numbered-table">
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>1.</td><td>we provide a small buffer, that lives on the stack</td></tr>
<tr><td>2.</td><td>this buffer is filled by the <em>writer</em> with characters that have to be written</td></tr>
<tr><td>3.</td><td>when the buffer is full, the <em>writer</em> actually writes the data, then empties the buffer and repeats</td></tr>
<tr><td>4.</td><td>when there's nothing more to write, there can be something left in the buffer, because the <em>writer</em> only writes the buffer when it's full</td></tr>
<tr><td>5.</td><td>so we <em>flush</em> the buffer: the <em>writer</em> empties it and writes what's left</td></tr>
</tbody></table>
</div></div>
<p>When we're done we print a message that says the name of the written file, how
many lines and bytes have been written to disk.</p>
<p>If for some reason the write fails, the buffer filename is freed and made null.</p>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="io/save.html#admonition-important"></a>
</div>
<div>
<p>The same remarks that have been made for the <code>Io.Reader</code> interface are valid
here: you <strong>can't</strong> make a copy of the interface, by assigning it directly:</p>
<pre class="code-block-small"><code class="language-zig">const interface = f.writer(&buf).interface; // WRONG
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompts"><a class="header" href="#prompts">Prompts</a></h1>
<p>We're back to the point where we need to interact with the user, in this case
to obtain a filename for a buffer that doesn't have one, so that we can save
it.</p>
<h3 id="the-prompt-function"><a class="header" href="#the-prompt-function">The prompt function</a></h3>
<p>We'll put this function in the Message Area section, right above the
<code>statusMessage</code> and <code>errorMessage</code> functions.</p>
<p>For now this is a simplified version, we'll have to expand it later, when we'll
want this prompt to accept a callback as argument, so that this callback can be
invoked at each user input. But right now we don't need it, so we keep it at
its simplest.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Start a prompt in the message area, return the user input.
/// Prompt is terminated with either .esc or .enter keys.
/// Prompt is also terminated by .backspace if there is no character left in
/// the input.
fn promptForInput(e: *Editor, prompt: []const u8) !t.Chars {
    var al = try t.Chars.initCapacity(e.alc, 80);

    while (true) {
        // read keys
    }
    e.clearStatusMessage();
    return al;
}
</code></pre>
<p>This function returns an ArrayList, which is allocated inside the function
itself. It's not a pointer to an existing ArrayList, it's a new one. The caller
must remember to deinitialize this ArrayList with a <code>defer</code> statement.</p>
<p>Note that in this case, returning a pointer to the ArrayList created in
<code>promptForInput()</code> would mean to return a dangling pointer, so we should
either:</p>
<ul>
<li>return a copy (doing this)</li>
<li>pass a pointer to an existing ArrayList as argument</li>
</ul>
<p>To be more explicit, we could pass the allocator to <code>promptForInput()</code>, but I'm
not doing it here.</p>
<h3 id="the-loop"><a class="header" href="#the-loop">The loop</a></h3>
<p>The loop reads typed characters in the ArrayList. Input is terminated with
<kbd>Esc</kbd> or <kbd>Enter</kbd>, and also with <kbd>Backspace</kbd> if the
prompt is empty. If you wondered if we can move the cursor inside the prompt,
the answer is no. But we can press <kbd>Backspace</kbd> to delete characters.</p>
<div class="code-title">Editor.zig: promptForInput() loop</div>
<pre><code class="language-zig">        try e.statusMessage("{s}{s}", .{ prompt, al.items });
        try e.refreshScreen();

        const k = try ansi.readKey();
        const c = @intFromEnum(k);

        switch (k) {
            .ctrl_h, .backspace =&gt; {
                if (al.items.len == 0) {
                    break;
                }
                _ = al.pop();
            },

            .esc, .enter =&gt; break,

            else =&gt; if (k == .tab or asc.isPrint(c)) {
                try al.append(e.alc, c);
            },
        }
</code></pre>
<p>When all is done, we clear the message area with this function, which we'll put
in the Helpers section:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Clear the message area. Can't fail because it won't reallocate.
fn clearStatusMessage(e: *Editor) void {
    e.status_msg.clearRetainingCapacity();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompting-for-a-filename"><a class="header" href="#prompting-for-a-filename">Prompting for a filename</a></h1>
<p>In <code>saveFile()</code> we had a placeholder of this case, and we'll replace it with:</p>
<div class="code-title">Editor.zig: saveFile()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">        // will prompt for a filename
        return;
</code></pre>
</div>
<pre><code class="language-zig">        var al = try e.promptForInput(message.prompt.get("fname").?);
        defer al.deinit(e.alc);

        if (al.items.len &gt; 0) {
            B.filename = try e.updateString(B.filename, al.items);
        }
        else {
            try e.statusMessage("Save aborted", .{});
            return;
        }
</code></pre>
<p>We need a new StringMap in our <code>message</code> module:</p>
<div class="code-title">message.zig</div>
<pre><code class="language-zig">const prompt_messages = .{
    .{ "fname", "Enter filename, or ESC to cancel: " },
};

pub const prompt = std.StaticStringMap([]const u8).initComptime(prompt_messages);
</code></pre>
<h3 id="binding-ctrl-s-to-save-the-file"><a class="header" href="#binding-ctrl-s-to-save-the-file">Binding Ctrl-S to save the file</a></h3>
<p>We don't have yet a way to save, because we didn't bind a key. We add a new
branch to the <code>processKeypress</code> function:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        .ctrl_s =&gt; try e.saveFile(),
</code></pre>
<p>And that's about it. If you compile and run with:</p>
<pre><code>./kilo some_new_file
</code></pre>
<p>you should be able to edit the file, give it a name and save it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highlight"><a class="header" href="#highlight">Highlight</a></h1>
<p>We have two features left to implement: searching and syntax highlighting.
Both of them require the ability to apply a different highlight to our text, so
we'll do that.</p>
<p>We'll do everything in the <code>types</code> module, but first we must define the color
codes that we'll be using. In <code>ansi</code> define these namespaced constants:</p>
<div class="code-title">ansi.zig</div>
<pre><code class="language-zig">/// Codes for 16-colors terminal escape sequences (foreground)
pub const FgColor = struct {
    pub const default: u8 = 39;
    pub const black: u8 = 30;
    pub const red: u8 = 31;
    pub const green: u8 = 32;
    pub const yellow: u8 = 33;
    pub const blue: u8 = 34;
    pub const magenta: u8 = 35;
    pub const cyan: u8 = 36;
    pub const white: u8 = 37;
    pub const black_bright: u8 = 90;
    pub const red_bright: u8 = 91;
    pub const green_bright: u8 = 92;
    pub const yellow_bright: u8 = 93;
    pub const blue_bright: u8 = 94;
    pub const magenta_bright: u8 = 95;
    pub const cyan_bright: u8 = 96;
    pub const white_bright: u8 = 97;
};

/// Codes for 16-colors terminal escape sequences (background)
pub const BgColor = struct {
    pub const default: u8 = 49;
    pub const black: u8 = 40;
    pub const red: u8 = 41;
    pub const green: u8 = 42;
    pub const yellow: u8 = 43;
    pub const blue: u8 = 44;
    pub const magenta: u8 = 45;
    pub const cyan: u8 = 46;
    pub const white: u8 = 47;
    pub const black_bright: u8 = 100;
    pub const red_bright: u8 = 101;
    pub const green_bright: u8 = 102;
    pub const yellow_bright: u8 = 103;
    pub const blue_bright: u8 = 104;
    pub const magenta_bright: u8 = 105;
    pub const cyan_bright: u8 = 106;
    pub const white_bright: u8 = 107;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highlight-enum"><a class="header" href="#highlight-enum">Highlight enum</a></h1>
<p>We need to define the <code>Highlight</code> enum, which goes in <code>types</code>. We start with
few values and will expand it later:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Highlight
//
///////////////////////////////////////////////////////////////////////////////

/// All available highlight types.
pub const Highlight = enum(u8) {
    /// The normal highlight
    normal = 0,

    /// Incremental search highlight
    incsearch,

    /// Highlight for error messages
    err,
};
</code></pre>
<h3 id="an-array-for-highlight"><a class="header" href="#an-array-for-highlight">An array for highlight</a></h3>
<p>Our Row type must have an additional array, which will have the same length
of the <code>render</code> array, and which will contain the <code>Highlight</code> for each
element of the <code>render</code> array:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">/// Array with the highlight of the rendered row
hl: []t.Highlight,
</code></pre>
<p>We'll initialize this array in <code>Row.init()</code>:</p>
<pre><code class="language-zig">        .hl = &amp;.{},
</code></pre>
<p>deinitialize it in <code>Row.deinit()</code>:</p>
<pre><code class="language-zig">    allocator.free(row.hl);
</code></pre>
<p>and will fill it in a new function:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Syntax highlighting
//
///////////////////////////////////////////////////////////////////////////////

/// Update highlight for a row.
fn updateHighlight(e: *Editor, ix: usize) !void {
    const row = e.rowAt(ix);

    // reset the row highlight to normal
    row.hl = try e.alc.realloc(row.hl, row.render.len);
    @memset(row.hl, .normal);
}
</code></pre>
<p>Later we'll do syntax highlighting here. This function is called at the end of
<code>updateRow()</code>, because every time the rendered row is updated, its highlight
must be too.</p>
<div class="code-title">Editor.zig: updateRow()</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    try e.updateHighlight(ix);
</code></pre>
</div>
<pre><code>}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highlight-groups"><a class="header" href="#highlight-groups">Highlight groups</a></h1>
<p>Highlight groups have properties, which we define in a new type.</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// Attributes of a highlight group.
pub const HlGroup = struct {
    /// Foreground CSI color code
    fg: u8,

    /// Background CSI color code
    bg: u8,

    reverse: bool,
    bold: bool,
    italic: bool,
    underline: bool,
};
</code></pre>
<h3 id="an-array-of-highlight-groups"><a class="header" href="#an-array-of-highlight-groups">An array of highlight groups</a></h3>
<p>We create the array with the highlight groups in a new module <code>hlgroups.zig</code>,
since an array isn't a <strong>Type</strong>.</p>
<p>We add already a helper to get the index for the array when initializing it.</p>
<div class="code-title">hlgroups.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Highlight groups
//
///////////////////////////////////////////////////////////////////////////////

// here goes the hlGroups array

// Get the enum value as integer, so that it can be used as array index.
fn int(ef: t.Highlight) usize {
    return @intFromEnum(ef);
}

///////////////////////////////////////////////////////////////////////////////
//
//                              Constants, variables
//
///////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const t = @import("types.zig");

const ansi = @import("ansi.zig");
const CSI = ansi.CSI;
const FgColor = ansi.FgColor;
const BgColor = ansi.BgColor;
</code></pre>
<p>Here things become really interesting, so pay attention.</p>
<p>We must define an array of highlight groups. There are no designated
initializers in Zig, so we use a <a href="https://ziglang.org/documentation/0.15.1/#Blocks"><em>labeled
block</em></a> to make up for them.
At the same time, you'll see that these blocks let us do some wondrous things.</p>
<p>This block must return an array of <code>HlGroup</code>, with a size that is the number of
the fields of the <code>Highlight</code> enum. We don't want to guess how many highlight
types we have, so we get the exact number of them. We can do so with:</p>
<pre><code>@typeInfo(EnumType).@"enum".fields.len
</code></pre>
<details id="admonition--notation-for-identifiers" class="admonition admonish-note" role="note" aria-labelledby="admonition--notation-for-identifiers-title">
<summary class="admonition-title">
<div id="admonition--notation-for-identifiers-title">
<p>@" notation for identifiers</p>
</div>
<a class="admonition-anchor-link" href="highlight/hlgroups.html#admonition--notation-for-identifiers"></a>
</summary>
<div>
<p>From the <a href="https://ziglang.org/documentation/0.15.1/#Identifiers">official
documentation</a>:</p>
<pre><code>Variable identifiers are never allowed to shadow identifiers from an outer
scope. Identifiers must start with an alphabetic character or underscore
and may be followed by any number of alphanumeric characters or
underscores. They must not overlap with any keywords.
</code></pre>
<p>If an identifier wouldn't be valid according to this rules, we can use the <code>@"</code>
notation. In our case we write <code>@"enum"</code> because <code>enum</code> is a keyword.</p>
</div>
</details>
<div class="code-title">hlgroups.zig</div>
<pre><code class="language-zig">// Number of members in the Highlight enum
const n_hl = @typeInfo(t.Highlight).@"enum".fields.len;

/// Array with highlight groups.
pub const hlGroups: [n_hl]t.HlGroup = arr: {
    // Initialize the hlGroups array at compile time. A []HlGroup array is
    // first declared undefined, then it is filled with all highlight groups.
    var hlg: [n_hl]t.HlGroup = undefined;
    hlg[int(.normal)] = .{
        .fg = FgColor.default,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.incsearch)] = .{
        .fg = FgColor.green,
        .bg = BgColor.default,
        .reverse = true,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.err)] = .{
        .fg = FgColor.red_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = true,
        .italic = false,
        .underline = false,
    };
    break :arr hlg;
};
</code></pre>
<h3 id="an-array-of-highlight-attributes"><a class="header" href="#an-array-of-highlight-attributes">An array of highlight attributes</a></h3>
<p>We also define an array with the <em>attributes</em> (the generated CSI sequences) for
all highlight groups. Also this one is created with a labeled block.</p>
<p>In this last block there's a loop: from the previously defined highlight
groups, it will generate the CSI escape sequence (the attribute) of the group
itself. This sequence is what we will actually use in the program to apply the
highlight.</p>
<div class="code-title">hlgroups.zig</div>
<pre><code class="language-zig">/// Array with highlight attributes.
pub const hlAttrs: [n_hl][]const u8 = arr: {
    // generate the attribute for each of the highlight groups
    // bold/italic/etc: either set them, or reset them to avoid their
    // propagation from previous groups
    var hla: [n_hl][]const u8 = undefined;
    for (hlGroups, 0..) |hlg, i| {
        hla[i] = CSI ++ std.fmt.comptimePrint("{s}{s}{s}{s}{};{}m", .{
            if (hlg.bold) "1;" else "22;",
            if (hlg.italic) "3;" else "23;",
            if (hlg.underline) "4;" else "24;",
            if (hlg.reverse) "7;" else "27;",
            hlg.fg,
            hlg.bg,
        });
    }
    break :arr hla;
};
</code></pre>
<p>Maybe you didn't realize yet why it's so awesome: everything here is done at
compile time! There won't be trace of this in the binary executable, except the
resulting <code>hlAttrs</code> array. The block doesn't use the <code>comptime</code> keyword, if you
use it the compiler will tell you</p>
<pre><code>error: redundant comptime keyword in already comptime scope
</code></pre>
<p>As proof that the <code>comptime</code> keyword is unnecessary most of the times.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="highlight/hlgroups.html#admonition-note"></a>
</div>
<div>
<p>The <code>hlGroups</code> array isn't used at runtime. Still, defining it is useful
because we can change more easily the highlight groups. The compiler keeps out
of the executable what isn't used at runtime anyway.</p>
</div>
</div>
<h3 id="how-we-access-the-attribute"><a class="header" href="#how-we-access-the-attribute">How we access the attribute</a></h3>
<p>We'll create a method in the <code>HlGroup</code> type that returns the attribute for that
highlight type:</p>
<div class="code-title">types.zig: HlGroup</div>
<pre><code class="language-zig">    underline: bool,
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    /// Get the attribute of a HlGroup from the hlAttrs array.
    pub fn attr(color: Highlight) []const u8 {
        return hlAttrs[@intFromEnum(color)];
    }
</code></pre>
</div>
<p>And import the array:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">const hlAttrs = @import("hlgroups.zig").hlAttrs;
</code></pre>
<details id="admonition-csi-escape-sequences" class="admonition admonish-note" role="note" aria-labelledby="admonition-csi-escape-sequences-title">
<summary class="admonition-title">
<div id="admonition-csi-escape-sequences-title">
<p>CSI escape sequences</p>
</div>
<a class="admonition-anchor-link" href="highlight/hlgroups.html#admonition-csi-escape-sequences"></a>
</summary>
<div>
<p>The <em>attribute</em> of each highlight group is a string: the escape sequence that
is fed to the terminal to get the highlight we want. The format is:</p>
<pre><code>ESC[{bold};{italic};{underline};{reverse};{fg-color};{bg-color}m
</code></pre>
<p>For example, if a group wants bold text, it will start with</p>
<pre><code>\x1b[1;
</code></pre>
<p>If it doesn't want it, it will reset the bold attribute with</p>
<pre><code>\x1b[22;
</code></pre>
<p>Otherwise it would inherit the value of the group that preceded it, whatever it
was.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-comptime"><a class="header" href="#more-comptime">More comptime</a></h1>
<p>We used a hard-coded <code>ErrorColor</code> when printing errors in the message area,
time to change it in <code>errorMessage()</code>:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    const fmt = ansi.ErrorColor ++ format ++ ansi.ResetColors;
</code></pre>
</div>
<pre><code class="language-zig">    const fmt = comptime t.HlGroup.attr(.err) ++ format ++ ansi.ResetColors;
</code></pre>
<p>You should now delete the <code>ErrorColor</code> constant from <code>ansi</code>.</p>
<p>Note the <code>comptime</code> keyword here. Without it, the compiler would say:</p>
<pre><code>error: unable to resolve comptime value
note: slice being concatenated must be comptime-known
</code></pre>
<p>With the <code>comptime</code> keyword, you force the compiler to at least <em>try</em> to get
that value at compile time. In this case, it succeeds. Also note that
<code>comptime</code> can precede any expression, to force it being evaluated at compile
time: function calls, assignments, etc.</p>
<p><strong>Again</strong>: you generally don't need the <code>compile</code> keyword. But if the compiler
complains with that sort of errors, and you think it should be able to get the
value, it's worth a try.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applying-the-highlight"><a class="header" href="#applying-the-highlight">Applying the highlight</a></h1>
<p>We have now all we need to apply the highlight. This should be done where rows
are drawn, in <code>drawRows()</code>. There, until now, we were simply drawing the
rendered row as-is. This must change into:</p>
<p>We get the portion of the line that starts at <code>coloff</code>, and we iterate it for
<code>len</code> characters, so that we only iterate the part of the line that can fit the
screen:</p>
<div class="code-title">drawRows() outer loop</div>
<div class="code-diff-removed">
<pre><code class="language-zig">            if (len &gt; 0) {
                try e.toSurface(rows[ix].render[V.coloff .. V.coloff + len]);
            }
</code></pre>
</div>
<pre><code class="language-zig">            // part of the line after coloff, and its highlight
            const rline = if (len &gt; 0) rows[ix].render[V.coloff..] else &amp;.{};
            const hl = if (len &gt; 0) rows[ix].hl[V.coloff..] else &amp;.{};
</code></pre>
<p>Inside the inner loop we check the character highlight, if it's different, we
apply the highlight attribute, which will remain enabled until a different
highlight is found in the <code>row.hl</code> array:</p>
<pre><code class="language-zig">            var current_color = t.Highlight.normal;

            // loop characters of the rendered row
            for (rline[0..len], 0..) |c, i| {
                if (hl[i] != current_color) {
                    const color = hl[i];
                    current_color = color;
                    try e.toSurface(t.HlGroup.attr(color));
                }
</code></pre>
<p>We draw the character. At the end of the line we restore default highlight,
otherwise the last highlight would carry over beyond the end of the line, and
onto the next line:</p>
<pre><code class="language-zig">                try e.toSurface(c);
            }
            // end of the line, reset highlight
            try e.toSurface(ansi.ResetColors);
</code></pre>
<details id="admonition-safe-to-iterate-zero-length-slices" class="admonition admonish-note" role="note" aria-labelledby="admonition-safe-to-iterate-zero-length-slices-title">
<summary class="admonition-title">
<div id="admonition-safe-to-iterate-zero-length-slices-title">
<p>Safe to iterate zero-length slices?</p>
</div>
<a class="admonition-anchor-link" href="highlight/apply.html#admonition-safe-to-iterate-zero-length-slices"></a>
</summary>
<div>
<p>We can safely iterate a zero-length slice with a for loop. For example this
just prints <code>nothing</code>:</p>
<pre><code class="language-zig">
    const line: []const u8 = &.{};
    for (line) |c| {
        std.debug.print("{}\n", .{c});
        break;
    } else {
        std.debug.print("nothing\n", .{});
    }
</code></pre>
<p>We could not do this with a while loop, because we would need to actually
access the line by index.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highlight-for-non-printable-characters"><a class="header" href="#highlight-for-non-printable-characters">Highlight for non-printable characters</a></h1>
<p>As a first proof-of-concept for our highlight, we want non-printable characters
to be printed with a reversed highlight (black on white), for example we'll
turn <kbd>Ctrl-A</kbd> into <code>A</code> with reversed colors. If the character is not
a Ctrl character, it will be printed as <code>?</code> with reversed colors.</p>
<p>It won't work for some charcters like <kbd>Tab</kbd> or <kbd>Backspace</kbd>,
though, but for now it will do.</p>
<p>This kind of highlight will work with all filetypes, so we aren't talking about
<em>syntax</em> highlighting yet.</p>
<p>We'll need a way to insert non-printable characters, so we define a key
(<kbd>Ctrk-K</kbd>) which will let us insert characters <em>verbatim</em>, even those
that we couldn't type anyway. For example <kbd>Ctrl-Q</kbd> would quit, it
would not insert it. But while inserting characters <em>verbatim</em> we'll be able to
type it.</p>
<h3 id="process-verbatim-keypresses"><a class="header" href="#process-verbatim-keypresses">Process <em>verbatim</em> keypresses</a></h3>
<p>In <code>processKeypress()</code>, we add a variable <code>verbatim</code> in the <code>static</code> struct:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">    const static = struct {
        var q: u8 = opt.quit_times;
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">        var verbatim: bool = false;
</code></pre>
</div>
<p>Just below the <code>static</code> struct definition, before processing keypresses, we
check if the variable was set, in this case we reset the variable, insert the
character and return. There is a set of characters that we don't insert,
because we cannot handle them at this point, they would just break our text.</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">    if (static.verbatim) {
        static.verbatim = false;
        switch (k) {
            // these cause trouble, don't insert them
            .enter,
            .ctrl_h,
            .backspace,
            .ctrl_j,
            .ctrl_k,
            .ctrl_l,
            .ctrl_u,
            .ctrl_z,
            =&gt; {
                try e.errorMessage(message.errors.get("nonprint").?, .{ k });
                return;
            },
            else =&gt; try e.insertChar(@intFromEnum(k)),
        }
        return;
    }
</code></pre>
<p>We'll make <kbd>Ctrl-K</kbd> set this variable to <code>true</code>:</p>
<div class="code-title">Editor.zig: processKeypress() switch</div>
<pre><code class="language-zig">        .ctrl_k =&gt; static.verbatim = true,
</code></pre>
<p>For the error, we need the <code>nonprint</code> error message:</p>
<div class="code-title">message.zig: error_messages</div>
<pre><code class="language-zig">    .{ "nonprint", "Can't insert character: {any}" },
</code></pre>
<h3 id="highlight-the-verbatim-characters"><a class="header" href="#highlight-the-verbatim-characters">Highlight the <em>verbatim</em> characters</a></h3>
<p>This highlight group is filetype-independent, so we just handle it in the
<code>drawRows()</code> inner loop:</p>
<div class="code-title">Editor.zig: drawRows() inner loop</div>
<div class="code-diff-removed">
<pre><code class="language-zig">                if (hl[i] != current_color) {
</code></pre>
</div>
<pre><code class="language-zig">                if (c != '\t' and !asc.isPrint(c)) {
                    // for example, turn Ctrl-A into 'A' with reversed colors
                    current_color = t.Highlight.nonprint;
                    try e.toSurface(t.HlGroup.attr(.nonprint));
                    try e.toSurface(switch (c) {
                        0...26 =&gt; '@' + c,
                        else =&gt; '?',
                    });
                }
                else if (hl[i] != current_color) {
</code></pre>
<p>We also need to add <code>nonprint</code> to the <code>Highlight</code> enum:</p>
<div class="code-title">types.zig: Highlight enum</div>
<pre><code class="language-zig">    /// Highlight for non-printable characters
    nonprint,
</code></pre>
<h3 id="define-the-highlight-group"><a class="header" href="#define-the-highlight-group">Define the highlight group</a></h3>
<p>Now, if you try to compile, the compiler will say something like:</p>
<pre><code>src/types.zig|162 col 20| error: use of undefined value here causes illegal behavior
||             if (hlg.bold) "1;" else "22;",
</code></pre>
<p>That's because we didn't define the highlight group in <code>hlGroups</code>, but the
<code>hlAttrs</code> initializer tries to access it. This means that our system is really
ok! We can't forget to define groups without the compiler telling us.</p>
<p>So we add the highlight group in the <code>hlGroups</code> labeled block:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">    hlg[int(.nonprint)] = .{
        .fg = FgColor.white,
        .bg = BgColor.default,
        .reverse = true,
        .bold = false,
        .italic = false,
        .underline = false,
    };
</code></pre>
<p>Now it should compile and the following should work:</p>
<ul>
<li>
<p>try inserting a non-printable character with <kbd>Ctrl-K</kbd> followed by
<kbd>Ctrl-A</kbd></p>
</li>
<li>
<p>now try pressing two times <kbd>Ctrl-K</kbd>: we decided not insert certain
characters and print an error message instead, this should have the <code>.err</code>
highlight.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching"><a class="header" href="#searching">Searching</a></h1>
<p>Now that we can prompt the user for input, and we can apply highlight to the
text, we could give our editor the capability to search for words in the file.</p>
<p>To be able to do this, we'll need several changes. We defined the <code>incsearch</code>
highlight, so we don't need to do that.</p>
<p>Instead, we must change how <code>promptForInput()</code> works. Until now, it only
prompted a string from the user and returned it, without doing anything in
between.</p>
<p>Now instead we want that every time the user types a character, the currently
typed pattern will be searched, and if found it will be given a highlight on
the screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-prompt-callback"><a class="header" href="#the-prompt-callback">The prompt callback</a></h1>
<p>To achieve this, we will need our <code>promptForInput()</code> function to accept
a callback function as parameter, and call it repeatedly inside its body.</p>
<p>We define the callback types as follows:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Callbacks
//
///////////////////////////////////////////////////////////////////////////////

/// The prompt callback function type
pub const PromptCb = fn (*Editor, PromptCbArgs) EditorError!void;

/// Arguments for the prompt callback
pub const PromptCbArgs = struct {
    /// Current input entered by user
    input: *Chars,

    /// Last typed key
    key: Key,

    /// Saved view, in case it needs to be restored
    saved: View,

    /// Becomes true in the last callback invocation
    final: bool = false,
};
</code></pre>
<p>Note how easy and clear it is in Zig to define <em>typedefs</em> (as they are named in
C), as we do for <code>PromptCb</code>.</p>
<p>Then we change the <code>promptForInput()</code> signature to:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">/// Start a prompt in the message area, return the user input.
/// Prompt is terminated with either .esc or .enter keys.
/// Prompt is also terminated by .backspace if there is no character left in
/// the input.
fn promptForInput(e: *Editor, prompt: []const u8) !t.Chars {
</code></pre>
</div>
<pre><code class="language-zig">/// Start a prompt in the message area, return the user input.
/// At each keypress, the prompt callback is invoked, with a final invocation
/// after the prompt has been terminated with either .esc or .enter keys.
/// Prompt is also terminated by .backspace if there is no character left in
/// the input.
fn promptForInput(e: *Editor, prompt: []const u8, saved: t.View, cb: ?t.PromptCb) !t.Chars {
    _ = cb;
    _ = saved;
</code></pre>
<p>We'll have to fix the previous invocation:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">        var al = try e.promptForInput(message.prompt.get("fname").?);
</code></pre>
</div>
<pre><code class="language-zig">        var al = try e.promptForInput(message.prompt.get("fname").?, .{}, null);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editorerror-set"><a class="header" href="#editorerror-set"><code>EditorError</code> set</a></h1>
<p>If you try to compile now, the compiler will tell you that this error doesn't
exist. If you try to remove it from the <code>PromptCb</code> return value, the compiler
will tell you</p>
<pre><code>error: function type cannot have an inferred error set
</code></pre>
<p>So we need an explicit error set for our callback. We don't know how many kinds
of errors could cause a <code>PromptCb</code> to fail. The callback we'll be using for the
searching function will be of type</p>
<pre><code>error{OutOfMemory}
</code></pre>
<p>So we could just write that. But <code>PromptCb</code> is a 'generic' callback, which
could do just about anything, and we'd need to add more errors to that set.</p>
<p>Instead, we create our <code>EditorError</code> set, and if we'll need to handle more
errors, we'll add them to this set.</p>
<p>Just add it above our previous <code>IoError</code> set:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// Error set for functions requiring explicit error handling.
pub const EditorError = error{
    OutOfMemory,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updated-promptforinput"><a class="header" href="#updated-promptforinput">Updated <code>promptForInput()</code></a></h1>
<p>Remove those assignments at the top:</p>
<div class="code-title">Editor.zig: promptForInput()</div>
<div class="code-diff-removed">
<pre><code class="language-zig">    _ = cb;
    _ = saved;
</code></pre>
</div>
<p>Now our prompt function needs to invoke this <code>PromptCb</code> callback.</p>
<p>Before the loop starts, we want to define some variables:</p>
<div class="code-title">Editor.zig: promptForInput()</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    var k: t.Key = undefined;
    var c: u8 = undefined;
    var cb_args: t.PromptCbArgs = undefined;
</code></pre>
</div>
<pre><code class="language-zig">    while (true) {
</code></pre>
<p>which we'll assign inside the loop:</p>
<pre><code class="language-zig">    while (true) {
        try e.statusMessage("{s}{s}", .{ prompt, al.items });
        try e.refreshScreen();
</code></pre>
<div class="code-diff-removed">
<pre><code class="language-zig">        const k = try ansi.readKey();
        const c = @intFromEnum(k);
</code></pre>
</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">        k = try ansi.readKey();
        c = @intFromEnum(k);
        cb_args = .{ .input = &amp;al, .key = k, .saved = saved };
</code></pre>
</div>
<p>Before the loop ends, we run the callback, if not <code>null</code>:</p>
<div class="code-diff-added-top">
<pre><code class="language-zig">        if (cb) |callback| try callback(e, cb_args);
</code></pre>
</div>
<pre><code class="language-zig">    }
    e.clearStatusMessage();
</code></pre>
<p>After the loop, we call it one last time before returning the input:</p>
<div class="code-diff-removed">
<pre><code class="language-zig">    e.clearStatusMessage();
    return al;
</code></pre>
</div>
<pre><code class="language-zig">    e.clearStatusMessage();
    cb_args.final = true;
    if (cb) |callback| try callback(e, cb_args);
    return al;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doing-the-search"><a class="header" href="#doing-the-search">Doing the search</a></h1>
<p>Our prompt accepts a callback now, so we're ready to implement the search
functionality.</p>
<p>We bind a new key:</p>
<div class="code-title">Editor.zig: processKeypress()</div>
<pre><code class="language-zig">        .ctrl_f =&gt; try e.find(),
</code></pre>
<p>Then we define our function:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Find
//
///////////////////////////////////////////////////////////////////////////////

/// Start the search prompt.
fn find(e: *Editor) !void {
    const saved = e.view;
    var query = try e.promptForInput("/", saved, findCallback);
    query.deinit(e.alc);
}
</code></pre>
<p>In this function, we make a copy of the current View, so that we can restore
the cursor position in the case that the search is interrupted.</p>
<p>We get our query, then deinitialize it. It's clear we're missing some piece of
the puzzle...</p>
<p>Which brings us to the <code>findCallback()</code> function, which is passed to the
prompt.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-find-callback-preparations"><a class="header" href="#the-find-callback-preparations">The find callback: preparations</a></h1>
<p>We'll have to break the code for the <em>find</em> callback in pieces somehow.</p>
<p>We also need some additional preparations.</p>
<h3 id="pos-type"><a class="header" href="#pos-type"><code>Pos</code> type</a></h3>
<p>We need a type that represents a position in the buffer.</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// A position in the buffer.
pub const Pos = struct {
    lnr: usize = 0,
    col: usize = 0,
};
</code></pre>
<h3 id="wrapscan-option"><a class="header" href="#wrapscan-option"><code>wrapscan</code> option</a></h3>
<p>We need an option for the searching behavior: should the search continue when
the end of file is reached, by repeating the search from the start of the file?
This also works while searching backwards:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">/// Searches wrap around the end of the file
pub var wrapscan = true;
</code></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<p>We need two new constants:</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const lastIndexOf = mem.lastIndexOf;
const indexOf = mem.indexOf;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-findcallback-function"><a class="header" href="#the-findcallback-function">The <code>findCallback()</code> function</a></h1>
<p>This one is big. We'll start with a stub, filled with placeholders. We reset
the highlight and we handle clean up at the start of the function, so that
later it can return at any point.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Called by promptForInput() for every valid inserted character.
/// The saved view is restored when the current query isn't found, or when
/// backspace clears the query, so that the search starts from the original
/// position.
fn findCallback(e: *Editor, ca: t.PromptCbArgs) t.EditorError!void {
    // 1. variables
    // 2. restore line highlight
    // 3. clean up
    // 4. query is empty so no need to search, but restore position
    // 5. handle backspace
    // 6. find the starting line and the column offset for the search
    // 7. start the search
}
</code></pre>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>As we did before, we have a <code>static</code> struct which will save the current state
of the search.</p>
<pre><code class="language-zig">    const static = struct {
        var found: bool = false;
        var view: t.View = .{};
        var pos: t.Pos = .{};
        var oldhl: []t.Highlight = &amp;.{};
    };
</code></pre>
<p>We also define some constants:</p>
<pre><code class="language-zig">    const empty = ca.input.items.len == 0;
    const numrows = e.buffer.rows.items.len;
</code></pre>
<h3 id="restore-line-highlight-before-incsearch-highlight"><a class="header" href="#restore-line-highlight-before-incsearch-highlight">Restore line highlight before incsearch highlight</a></h3>
<p>Before a new search attempt, we restore the underlying line highlight, so that
if the search fails, the search highlight has been cleared already.</p>
<pre><code class="language-zig">    // restore line highlight before incsearch highlight, or clean up
    if (static.oldhl.len &gt; 0) {
        @memcpy(e.rowAt(static.pos.lnr).hl, static.oldhl);
    }
</code></pre>
<h3 id="clean-up"><a class="header" href="#clean-up">Clean up</a></h3>
<p>The clean up must also be handled early. This block runs during the last
invocation of the callback, that is done for this exact purpose.</p>
<p>In this step we free the search highlight, reset our static variables and
restore the view if necessary.</p>
<pre><code class="language-zig">    // clean up
    if (ca.final) {
        e.alc.free(static.oldhl);
        static.oldhl = &amp;.{};
        if (empty or ca.key == .esc) {
            e.view = ca.saved;
        }
        if (!static.found and ca.key == .enter) {
            try e.statusMessage("No match found", .{});
        }
        static.found = false;
        return;
    }
</code></pre>
<h3 id="empty-query"><a class="header" href="#empty-query">Empty query</a></h3>
<p>This happens after we press <kbd>Backspace</kbd> and the query is now empty.
We don't cancel the search yet, but we restore the original view.
Search will be canceled if we press <kbd>Backspace</kbd> again.
We also reset <code>static.found</code> because it was true if that character we just
deleted was a match.</p>
<pre><code class="language-zig">    // Query is empty so no need to search, but restore position
    if (empty) {
        static.found = false;
        e.view = ca.saved;
        return;
    }
</code></pre>
<h3 id="handle-backspace"><a class="header" href="#handle-backspace">Handle <kbd>Backspace</kbd></a></h3>
<p>This happens when we press <kbd>Backspace</kbd>, but the query is not empty.
In this case we restore our static view, which is set later on. Note that if
the current query can't be found, this would be the same of the original view,
but what matters is that we must restore it, whatever it is.</p>
<pre><code class="language-zig">    // when pressing backspace we restore the previously saved view
    // cursor might move or not, depending on whether there is a match at
    // cursor position
    if (ca.key == .backspace or ca.key == .ctrl_h) {
        e.view = static.view;
    }
</code></pre>
<h3 id="find-the-starting-position-for-the-search"><a class="header" href="#find-the-starting-position-for-the-search">Find the starting position for the search</a></h3>
<p>We define some constants, to make the function flow more understandable.</p>
<pre><code class="language-zig">    //////////////////////////////////////////
    //   Find the starting position
    //////////////////////////////////////////

    const V = &amp;e.view;

    const prev = ca.key == .ctrl_t;
    const next = ca.key == .ctrl_g;

    // current cursor position
    var pos = t.Pos{ .lnr = V.cy, .col = V.cx };

    const eof = V.cy == numrows;
    const last_char_in_row = !eof and V.rx == e.currentRow().render.len;
    const last_row = V.cy == numrows - 1;

    // must move the cursor forward before searching when we don't want to
    // match at cursor position
    const step_fwd = next or empty or !static.found;
</code></pre>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="search/findcb.html#admonition-warning"></a>
</div>
<div>
<p>If we skip the <code>!eof</code> check when defining <code>last_char_in_row</code>, we would cause
panic when starting a search at the end of the file. This happens because
<code>e.currentRow()</code> tries to get a pointer to a line that doesn't exist. Watch out
for these things!</p>
</div>
</div>
<p>We are determining where the search must start, and that's either at cursor
position, or just after that (one character to the right). That is, we must
decide whether to accept a match at cursor position or not.</p>
<p>We want to step forward:</p>
<ul>
<li>
<p>if we press <kbd>Ctrl-G</kbd>, looking for the next match</p>
</li>
<li>
<p>if we are at the starting position, because either:</p>
<ul>
<li>we just started a search</li>
<li>query is empty</li>
<li>a match hasn't been found</li>
</ul>
</li>
</ul>
<p>In any of these cases:</p>
<pre><code class="language-zig">    if (step_fwd) {
        if (eof or (last_row and last_char_in_row)) {
            if (!opt.wrapscan) { // restart from the beginning of the file?
                return;
            }
        }
        else if (last_char_in_row) { // start searching from next line
            pos.lnr = V.cy + 1;
        }
        else { // start searching after current column
            pos.col = V.cx + 1;
            pos.lnr = V.cy;
        }
    }
</code></pre>
<h3 id="start-the-search"><a class="header" href="#start-the-search">Start the search</a></h3>
<p>Our match is an optional slice of the <code>chars.items</code> array of the Row where the
match was found. We try to find it with the appropriate functions, which we'll
define later.</p>
<pre><code class="language-zig">    //////////////////////////////////////////
    //          Start the search
    //////////////////////////////////////////

    var match: ?[]const u8 = null;

    if (!prev) {
        match = e.findForward(ca.input.items, &amp;pos);
    }
    else {
        match = e.findBackward(ca.input.items, &amp;pos);
    }

    static.found = match != null;
</code></pre>
<p>If a match is found, we update the cursor position and the static variables.</p>
<p>Since <code>match</code> is a slice of the original array, we can find the column with
pointer arithmetic, by subtracting the address of the first character of the
<code>chars.items</code> array from the address of the first character of our match.</p>
<pre><code class="language-zig">    const row = e.rowAt(pos.lnr);

    if (match) |m| {
        V.cy = pos.lnr;
        V.cx = &amp;m[0] - &amp;row.chars.items[0];

        static.view = e.view;
        static.pos = .{ .lnr = pos.lnr, .col = V.cx };
</code></pre>
<p><svg viewBox="0 0 500 130" xmlns="http://www.w3.org/2000/svg"><rect x="25" y="30" width="450" height="60" fill="#4ade80" stroke="#16a34a" stroke-width="2" opacity="0.7"/><rect x="175" y="30" width="120" height="60" fill="#f87171" stroke="#dc2626" stroke-width="2"/><text x="25" y="20" font-family="monospace" font-size="12" fill="#374151">&amp;row.chars.items[0]</text><text x="175" y="120" font-family="monospace" font-size="12" fill="#374151">&amp;m[0]</text><text x="205" y="65" font-family="Arial" font-size="14" fill="white" font-weight="bold">Match (m)</text><text x="35" y="55" font-family="Arial" font-size="14" fill="#16a34a" font-weight="bold">Row</text><text x="35" y="70" font-family="Arial" font-size="12" fill="#16a34a">(row.chars.items)</text></svg></p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="search/findcb.html#admonition-note"></a>
</div>
<div>
<p>Since we pass <code>&amp;pos</code> to the functions, we could set the column there,
but this works anyway (it's actually less trouble). Initially I wasn't using
Pos, but I'm keeping it to show an example of pointer arithmetic in Zig.
Feel free to refactor it if it suits you better.</p>
</div>
</div>
<p>Before setting the new highlight, we store a copy in <code>static.oldhl</code>. It will be
restored at the top of the callback, every time the callback is invoked.</p>
<p>Note that we are matching against <code>row.chars.items</code> (the real row), but the
highlight must match the characters in the rendered row, so we must convert our
match position first, with <code>cxToRx</code>.</p>
<pre><code class="language-zig">        // first make a copy of current highlight, to be restored later
        static.oldhl = try e.alc.realloc(static.oldhl, row.render.len);
        @memcpy(static.oldhl, row.hl);

        // apply search highlight
        const start = row.cxToRx(V.cx);
        const end = row.cxToRx(V.cx + m.len);
        @memset(row.hl[start .. end], t.Highlight.incsearch);
    }
</code></pre>
<p>If a match wasn't found, we restore the initial view (before we started
searching).</p>
<p>We must also handle the case that <code>wrapscan</code> is disabled, a match
isn't found in the current searching direction, but there was possibly a match
before, so we just remain there, and set the highlight at current position. We
need to set it because the original has been restored at the top.</p>
<p>Also here we do the same conversion, but we use the saved position.</p>
<pre><code class="language-zig">    else if (next or prev) {
        // the next match wasn't found in the searching direction
        // we still set the highlight for the current match, since the original
        // highlight has been restored at the top of the function
        // this can definitely happen with !wrapscan
        const start = row.cxToRx(static.pos.col);
        const end = row.cxToRx(static.pos.col + ca.input.items.len);
        @memset(row.hl[start .. end], t.Highlight.incsearch);
    }
    else {
        // a match wasn't found because the input couldn't be found
        // restore the original view (from before the start of the search)
        e.view = ca.saved;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-forwards"><a class="header" href="#search-forwards">Search forwards</a></h1>
<p>When searching forwards for a match, we start searching at the given position,
in the current row. We use the <code>std.mem.indexOf</code> function, that finds the
relative position of a slice in another slice, or returns <code>null</code> if the slice
isn't contained in the other slice.</p>
<p>Following steps are followed unless a match is returned.</p>
<div class="numbered-table">
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>•</td><td>search a slice of the current row <code>[col..]</code></td></tr>
<tr><td>•</td><td>reset search column to 0</td></tr>
<tr><td>•</td><td>search the following lines</td></tr>
<tr><td>•</td><td>end of file, no wrapscan? return null</td></tr>
<tr><td>•</td><td>restart from the beginning of the file</td></tr>
<tr><td>•</td><td>if you reach the initial line, only search <code>[..col]</code></td></tr>
</tbody></table>
</div></div>
<p>If a match is found, <code>pos.lnr</code> is updated, because the callback will need the
line where it was found.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Start a search forwards.
fn findForward(e: *Editor, query: []const u8, pos: *t.Pos) ?[]const u8 {
    var col = pos.col;
    var i = pos.lnr;

    while (i &lt; e.buffer.rows.items.len) : (i += 1) {
        const rowchars = e.rowAt(i).chars.items;

        if (indexOf(u8, rowchars[col..], query)) |m| {
            pos.lnr = i;
            return rowchars[(col + m)..(col + m + query.len)];
        }

        col = 0; // reset search column
    }

    if (!opt.wrapscan) {
        return null;
    }

    // wrapscan enabled, search from start of the file to current row
    i = 0;
    while (i &lt;= pos.lnr) : (i += 1) {
        const rowchars = e.rowAt(i).chars.items;

        if (indexOf(u8, rowchars, query)) |m| {
            pos.lnr = i;
            return rowchars[m .. m + query.len];
        }
    }
    return null;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-backward"><a class="header" href="#search-backward">Search backward</a></h1>
<p>The process is very similar, but in reverse. This time we use the
<code>std.mem.lastIndexOf</code> function, that finds the relative position of a slice in
another slice <em>before a certain index</em>, or returns <code>null</code> if the slice isn't
contained in the other slice.</p>
<p>Following steps are followed unless a match is returned.</p>
<div class="numbered-table">
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>•</td><td>search a slice of the current row <code>[0..col]</code></td></tr>
<tr><td>•</td><td>search the previous lines</td></tr>
<tr><td>•</td><td>start of file, no wrapscan? return null</td></tr>
<tr><td>•</td><td>restart from the end of the file</td></tr>
<tr><td>•</td><td>if you reach the initial line, only search <code>[col..]</code></td></tr>
</tbody></table>
</div></div>
<p>If a match is found, <code>pos.lnr</code> is updated, because the callback will need the
line where it was found.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Start a search backwards.
fn findBackward(e: *Editor, query: []const u8, pos: *t.Pos) ?[]const u8 {
    // first line, search up to col
    const row = e.rowAt(pos.lnr);
    const col = pos.col;
    var rowchars = row.chars.items;
    var i: usize = undefined;

    if (lastIndexOf(u8, rowchars[0..col], query)) |m| {
        return rowchars[m .. m + query.len];
    }
    else if (pos.lnr &gt; 0) {
        // previous lines, search full line
        i = pos.lnr - 1;
        while (true) : (i -= 1) {
            rowchars = e.rowAt(i).chars.items;

            if (lastIndexOf(u8, rowchars, query)) |m| {
                pos.lnr = i;
                return rowchars[m .. m + query.len];
            }
            if (i == 0) break;
        }
    }

    if (!opt.wrapscan) {
        return null;
    }

    i = e.buffer.rows.items.len - 1;
    while (i &gt; pos.lnr) : (i -= 1) {
        rowchars = e.rowAt(i).chars.items;

        if (lastIndexOf(u8, rowchars, query)) |m| {
            pos.lnr = i;
            return rowchars[m .. m + query.len];
        }
    }

    // check again the starting line, this time in the part after the offset
    rowchars = e.rowAt(pos.lnr).chars.items;

    if (lastIndexOf(u8, rowchars[col..], query)) |m| {
        // m is the index in the substring starting from `col`, therefore we
        // must add `col` to get the real index in the row
        return rowchars[m + col .. m + col + query.len];
    }
    return null;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-test-1"><a class="header" href="#write-a-test-1">Write a test</a></h1>
<p>By now you should be able to compile, run and test the feature yourself.</p>
<p>Anyway, the searching feature is way more complex than anything we did before,
and it's worth writing a test for it.</p>
<p>I don't know how to simulate keystrokes, so I'm just calling the callback
repeatedly.</p>
<p>I initialize the editor with a 'fake' screen, because this isn't an interactive
terminal.</p>
<p>Remember that we can do array multiplications (<code>**</code>) and concatenation (<code>++</code>),
but only in comptime scopes.</p>
<p>I won't explain what the test does, hopefully you'll be able to understand it.</p>
<div class="code-title">Editor.zig: Tests section</div>
<pre><code class="language-zig">test "find" {
    var da = std.heap.DebugAllocator(.{}){};
    defer _ = da.deinit();

    var e = try t.Editor.init(da.allocator(), .{ .rows = 50, .cols = 180 });
    defer e.deinit();

    opt.wrapscan = true;
    opt.tabstop = 8;

    // our test buffer
    try e.insertRow(e.buffer.rows.items.len, "\tabb");
    try e.insertRow(e.buffer.rows.items.len, "\tacc");
    try e.insertRow(e.buffer.rows.items.len, "\tadd\tadd");

    const n = [1]t.Highlight{ .normal };
    const s = [1]t.Highlight{ .incsearch };

    // Row.hl has the same number of elements as the rendered row, and here we
    // have tabs

    // first 2 lines: normal highlight
    const norm1 = n ** 11;
    // third line: normal highlight
    const norm2 = n ** 19;
    // \t + 1 letter in lines 1-2
    const hl = s ** 9 ++ n ** 2;
    // \t + 2 letters in lines 1-2
    const hl2 = s ** 10 ++ n ** 1;
    // \t + 2 letters in line 3, first match
    const hl3 = s ** 10 ++ n ** 9;
    // \t + 1 letter in line 3, first match
    const hl4 = s ** 9 ++ n ** 10;
    // \t + 1 letter in line 3, second match
    const hl5 = n ** 11 ++ s ** 6 ++ n ** 2;

    var al = try t.Chars.initCapacity(e.alc, 80);
    defer al.deinit(e.alc);

    // our prompt is "\ta", it should be found in line 2, because we skip the
    // match at cursor position
    try al.appendSlice(e.alc, "\ta");
    var ca: t.PromptCbArgs = .{ .input = &amp;al, .key = @enumFromInt('a'), .saved = e.view };
    try e.findCallback(ca);

    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;hl));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;norm2));

    // now it's "\tac", extending the current match
    try al.append(e.alc, 'c');
    ca = .{ .input = &amp;al, .key = @enumFromInt('c'), .saved = e.view };
    try e.findCallback(ca);

    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;hl2));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;norm2));

    // now it's "\ta", resizing the current match
    _ = al.pop();
    ca = .{ .input = &amp;al, .key = .backspace, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;hl));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;norm2));

    // now it's "\tad", found in line 3
    try al.append(e.alc, 'd');
    ca = .{ .input = &amp;al, .key = @enumFromInt('d'), .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;hl3));

    // now it's "\ta", resizes the current match
    _ = al.pop();
    ca = .{ .input = &amp;al, .key = .backspace, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;hl4));

    // find next: finds another "\ta" in the same row
    ca = .{ .input = &amp;al, .key = .ctrl_g, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;hl5));

    // find next again: finds "\ta" in the first line
    ca = .{ .input = &amp;al, .key = .ctrl_g, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;hl));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;norm2));

    // find prev: goes back to last line (2nd match)
    ca = .{ .input = &amp;al, .key = .ctrl_t, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;hl5));

    opt.wrapscan = false;

    // find next should fail (stays the same)
    ca = .{ .input = &amp;al, .key = .ctrl_g, .saved = e.view };
    try e.findCallback(ca);
    try expect(mem.eql(t.Highlight, e.rowAt(0).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(1).hl, &amp;norm1));
    try expect(mem.eql(t.Highlight, e.rowAt(2).hl, &amp;hl5));

    // clean up
    ca.final = true;
    try e.findCallback(ca);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax highlighting</a></h1>
<p>The last feature to implement is syntax highlighting.</p>
<h3 id="new-fields"><a class="header" href="#new-fields">New fields</a></h3>
<p>Add a new field in the <code>Buffer</code> type:</p>
<div class="code-title">Buffer.zig</div>
<pre><code class="language-zig">// Pointer to the syntax definition
syndef: ?*const t.Syntax,
</code></pre>
<p>And one in the <code>Row</code> type:</p>
<div class="code-title">Row.zig</div>
<pre><code class="language-zig">/// True when the row has a multiline comment continuing into next line
ml_comment: bool,
</code></pre>
<p>This one becomes true when a line contains the leader that opens the multi-line
comment, and stays true in all following rows, until the end of the block is
found, in that row it becomes false again.</p>
<div id="admonition-reminder" class="admonition admonish-tip" role="note" aria-labelledby="admonition-reminder-title">
<div class="admonition-title">
<div id="admonition-reminder-title">
<p>Reminder</p>
</div>
<a class="admonition-anchor-link" href="syntax/index.html#admonition-reminder"></a>
</div>
<div>
<p>Initialize both in their relative <code>init()</code>, to <code>null</code> and <code>false</code> respectively.
Add imports where necessary.</p>
</div>
</div>
<h3 id="fill-the-rest-of-highlight-enum"><a class="header" href="#fill-the-rest-of-highlight-enum">Fill the rest of Highlight enum</a></h3>
<p>This is the full Highlight enum, with all needed highlight names:</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">/// All available highlight types.
pub const Highlight = enum(u8) {
    /// The normal highlight
    normal = 0,

    /// Line comments highlight
    comment,

    /// Multiline comments highlight
    mlcomment,

    /// Numbers highlight
    number,

    /// String highlight
    string,

    /// Highlight for keywords of type 'keyword'
    keyword,

    /// Highlight for keywords of type 'types'
    types,

    /// Highlight for keywords of type 'builtin'
    builtin,

    /// Highlight for keywords of type 'constant'
    constant,

    /// Highlight for keywords of type 'preproc'
    preproc,

    /// Highlight for uppercase words
    uppercase,

    /// Highlight for escape sequences in strings
    escape,

    /// Incremental search highlight
    incsearch,

    /// Highlight for non-printable characters
    nonprint,

    /// Highlight for error messages
    err,
};
</code></pre>
<h3 id="fill-the-rest-of-hlgroups-array"><a class="header" href="#fill-the-rest-of-hlgroups-array">Fill the rest of hlGroups array</a></h3>
<p>This the full initializer of the <code>hlGroups</code> array, replace the previous one
with it.</p>
<div class="code-title">hlgroups.zig</div>
<pre><code class="language-zig">/// Array with highlight groups.
pub const hlGroups: [n_hl]t.HlGroup = arr: {
    // Initialize the hlGroups array at compile time. A []HlGroup array is
    // first declared undefined, then it is filled with all highlight groups.
    var hlg: [n_hl]t.HlGroup = undefined;
    hlg[int(.normal)] = .{
        .fg = FgColor.default,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.comment)] = .{
        .fg = FgColor.black_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.mlcomment)] = .{
        .fg = FgColor.blue_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.number)] = .{
        .fg = FgColor.white_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.string)] = .{
        .fg = FgColor.green,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.keyword)] = .{
        .fg = FgColor.cyan,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.types)] = .{
        .fg = FgColor.cyan_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.builtin)] = .{
        .fg = FgColor.magenta,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.constant)] = .{
        .fg = FgColor.yellow,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.preproc)] = .{
        .fg = FgColor.red_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.uppercase)] = .{
        .fg = FgColor.yellow_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.escape)] = .{
        .fg = FgColor.red,
        .bg = BgColor.default,
        .reverse = false,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.incsearch)] = .{
        .fg = FgColor.green,
        .bg = BgColor.default,
        .reverse = true,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.nonprint)] = .{
        .fg = FgColor.white,
        .bg = BgColor.default,
        .reverse = true,
        .bold = false,
        .italic = false,
        .underline = false,
    };
    hlg[int(.err)] = .{
        .fg = FgColor.red_bright,
        .bg = BgColor.default,
        .reverse = false,
        .bold = true,
        .italic = false,
        .underline = false,
    };
    break :arr hlg;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-types"><a class="header" href="#syntax-types">Syntax types</a></h1>
<p>You can either defined them in <code>types</code> module (which I do) or in a different
file, which will be imported by the <code>types</code> module, so that it's accessible
also from there.</p>
<h2 id="the-syntax-type"><a class="header" href="#the-syntax-type">The Syntax type</a></h2>
<p>This type defines many properities of a syntax: extensions used for filetype
detection, comment leaders, keywords and syntax-specific editor options.</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">///////////////////////////////////////////////////////////////////////////////
//
//                              Syntax types
//
///////////////////////////////////////////////////////////////////////////////

pub const Syntax = struct {
    /// Name of filetype
    ft_name: []const u8,

    /// Array of extensions for filetype detection
    ft_ext: []const []const u8,

    /// Array of names for filetype detection, to be matched against the tail
    /// of any path, so for example ".git/config" will match against any git
    /// configuration file in any directory.
    ft_fntails: []const []const u8,

    /// Leaders for single-line comments
    lcmt: []const []const u8,

    /// Array with multiline comment leaders
    /// [0] is start of block
    /// [1] is leader for lines between start and end
    /// [2] is end of block
    mlcmt: ?[3][]const u8,

    /// Array of words with 'Keywords' highlight
    keywords: []const []const u8,

    /// Array of words with 'Types' highlight
    types: []const []const u8,

    /// Array of words with 'Builtin' highlight
    builtin: []const []const u8,

    /// Array of words with 'Constant' highlight
    constant: []const []const u8,

    /// Array of words with 'Preproc' highlight
    preproc: []const []const u8,

    /// Bit field with supported syntax groups
    flags: SyntaxFlags,
};
</code></pre>
<h2 id="the-syntax-flags"><a class="header" href="#the-syntax-flags">The syntax flags</a></h2>
<p>This type is important because it controls the kinds of highlight that a syntax
supports, that is what the syntax highlighter will actually highlight when
parsing the buffer.</p>
<div class="code-title">types.zig</div>
<pre><code class="language-zig">pub const SyntaxFlags = packed struct {
    /// Should highlight integer and floating point numbers
    numbers: bool = false,

    /// Should highlight 0x[0-9a-fA-F]+ numbers
    hex: bool = false,

    /// Should highlight 0b[01]+ numbers
    bin: bool = false,

    /// Should highlight 0o[0-7]+ numbers
    octal: bool = false,

    /// Supports undescores in numeric literals
    uscn: bool = false,

    /// Should highlight strings
    strings: bool = false,

    /// Supports double-quoted strings
    dquotes: bool = false,

    /// Supports single-quoted strings
    squotes: bool = false,

    /// Highlight backticks as strings
    backticks: bool = false,

    /// Single-quotes are used for char literals instead
    chars: bool = false,

    /// Should highlight uppercase words
    uppercase: bool = false,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-definitions"><a class="header" href="#syntax-definitions">Syntax definitions</a></h1>
<p>I won't explain much of what goes on here: it's a list of syntax definitions,
with their flags, keywords and so on. Create a module named <code>syndefs.zig</code> and
copy-paste them.</p>
<p>You might note that all arrays have a <code>&amp;</code> in front of them. That's because the
<code>Syntax</code> type's fields are <em>slices</em>, for example <code>[]const []const u8</code>.
The only exception is <code>mlcmt</code>, because it has a fixed size, besides being
optional.</p>
<div class="code-title">syndefs.zig</div>
<pre><code class="language-zig">//! Module that contains all syntax definitions.

pub const Syntaxes = [_]t.Syntax{

    //////////////////////////////////////////////////////////////////////////
    //// zig
    .{
        .ft_name = "zig",
        .ft_ext = &amp;.{
            "zig",
            "zon",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"//"},
        .mlcmt = null,
        .keywords = &amp;.{
            "addrspace", "align",   "allowzero",      "and",
            "anyframe",  "anytype", "catch",          "const",
            "else",      "enum",    "error",          "fn",
            "for",       "if",      "opaque",         "or",
            "orelse",    "packed",  "struct",         "switch",
            "try",       "union",   "usingnamespace", "var",
            "volatile",  "while",
        },
        .types = &amp;.{
            "i8",          "u8",           "i16",            "u16",
            "i32",         "u32",          "i64",            "u64",
            "i128",        "u128",         "isize",          "usize",
            "c_char",      "c_short",      "c_ushort",       "c_int",
            "c_uint",      "c_long",       "c_ulong",        "c_longlong",
            "c_ulonglong", "c_longdouble", "f16",            "f32",
            "f64",         "f80",          "f128",           "bool",
            "anyopaque",   "void",         "noreturn",       "type",
            "anyerror",    "comptime_int", "comptime_float",
        },
        .builtin = &amp;.{
            "export",   "extern",      "noinline",    "nosuspend",
            "inline",   "suspend",     "async",       "await",
            "defer",    "errdefer",    "unreachable", "comptime",
            "continue", "return",      "resume",      "threadlocal",
            "callconv", "linksection", "asm",         "noalias",
            "test",     "pub",         "break",
        },
        .constant = &amp;.{
            "undefined", "true", "false", "null",
        },
        .preproc = &amp;.{
            "@addrSpaceCast",    "@addWithOverflow",    "@alignCast",
            "@alignOf",          "@as",                 "@atomicLoad",
            "@atomicRmw",        "@atomicStore",        "@bitCast",
            "@bitOffsetOf",      "@bitSizeOf",          "@branchHint",
            "@breakpoint",       "@mulAdd",             "@byteSwap",
            "@bitReverse",       "@offsetOf",           "@call",
            "@cDefine",          "@cImport",            "@cInclude",
            "@clz",              "@cmpxchgStrong",      "@cmpxchgWeak",
            "@compileError",     "@compileLog",         "@constCast",
            "@ctz",              "@cUndef",             "@cVaArg",
            "@cVaCopy",          "@cVaEnd",             "@cVaStart",
            "@divExact",         "@divFloor",           "@divTrunc",
            "@embedFile",        "@enumFromInt",        "@errorFromInt",
            "@errorName",        "@errorReturnTrace",   "@errorCast",
            "@export",           "@extern",             "@field",
            "@fieldParentPtr",   "@FieldType",          "@floatCast",
            "@floatFromInt",     "@frameAddress",       "@hasDecl",
            "@hasField",         "@import",             "@inComptime",
            "@intCast",          "@intFromBool",        "@intFromEnum",
            "@intFromError",     "@intFromFloat",       "@intFromPtr",
            "@max",              "@memcpy",             "@memset",
            "@min",              "@wasmMemorySize",     "@wasmMemoryGrow",
            "@mod",              "@mulWithOverflow",    "@panic",
            "@popCount",         "@prefetch",           "@ptrCast",
            "@ptrFromInt",       "@rem",                "@returnAddress",
            "@select",           "@setEvalBranchQuota", "@setFloatMode",
            "@setRuntimeSafety", "@shlExact",           "@shlWithOverflow",
            "@shrExact",         "@shuffle",            "@sizeOf",
            "@splat",            "@reduce",             "@src",
            "@sqrt",             "@sin",                "@cos",
            "@tan",              "@exp",                "@exp2",
            "@log",              "@log2",               "@log10",
            "@abs",              "@floor",              "@ceil",
            "@trunc",            "@round",              "@subWithOverflow",
            "@tagName",          "@This",               "@trap",
            "@truncate",         "@Type",               "@typeInfo",
            "@typeName",         "@TypeOf",             "@unionInit",
            "@Vector",           "@volatileCast",       "@workGroupId",
            "@workGroupSize",    "@workItemId",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .chars = true,
            .uppercase = true,
            .hex = true,
            .bin = true,
            .octal = true,
            .uscn = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// c
    .{
        .ft_name = "c",
        .ft_ext = &amp;.{
            "c", "h",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"//"},
        .mlcmt = .{ "/*", " *", "*/" },
        .keywords = &amp;.{
            "auto",           "case",          "const",
            "default",        "do",            "else",
            "enum",           "extern",        "for",
            "goto",           "if",            "inline",
            "register",       "restrict",      "sizeof",
            "static",         "struct",        "switch",
            "typedef",        "union",         "volatile",
            "while",          "_Alignas",      "_Alignof",
            "_Atomic",        "_Generic",      "_Noreturn",
            "_Static_assert", "_Thread_local",
        },
        .types = &amp;.{
            "void",     "char",       "short",    "int",       "long",
            "float",    "double",     "signed",   "unsigned",  "_Bool",
            "_Complex", "_Imaginary", "size_t",   "ptrdiff_t", "wchar_t",
            "int8_t",   "int16_t",    "int32_t",  "int64_t",   "uint8_t",
            "uint16_t", "uint32_t",   "uint64_t", "intptr_t",  "uintptr_t",
        },
        .builtin = &amp;.{
            "continue", "return", "break",
        },
        .constant = &amp;.{
            "NULL", "EOF", "true", "false", "TRUE", "FALSE",
        },
        .preproc = &amp;.{
            "#include",     "#define",  "#undef",           "#ifdef",
            "#ifndef",      "#if",      "#endif",           "#else",
            "#elif",        "#line",    "#error",           "#pragma",
            "#warning",     "__FILE__", "__LINE__",         "__DATE__",
            "__TIME__",     "__STDC__", "__STDC_VERSION__", "__func__",
            "__FUNCTION__",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .chars = true,
            .uppercase = true,
            .hex = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// c++
    .{
        .ft_name = "cpp",
        .ft_ext = &amp;.{
            "cpp", "cc", "cxx", "c++", "hpp", "hh", "hxx", "h++",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"//"},
        .mlcmt = .{ "/*", " *", "*/" },
        .keywords = &amp;.{
            "alignas",          "alignof",     "and",          "and_eq",
            "asm",              "auto",        "bitand",       "bitor",
            "case",             "catch",       "class",        "compl",
            "const",            "consteval",   "constexpr",    "constinit",
            "const_cast",       "co_await",    "co_return",    "co_yield",
            "decltype",         "default",     "delete",       "do",
            "dynamic_cast",     "else",        "enum",         "explicit",
            "export",           "extern",      "for",          "friend",
            "goto",             "if",          "inline",       "mutable",
            "namespace",        "new",         "noexcept",     "not",
            "not_eq",           "operator",    "or",           "or_eq",
            "private",          "protected",   "public",       "register",
            "reinterpret_cast", "requires",    "sizeof",       "static",
            "static_assert",    "static_cast", "struct",       "switch",
            "template",         "this",        "thread_local", "throw",
            "try",              "typedef",     "typeid",       "typename",
            "union",            "using",       "virtual",      "volatile",
            "while",            "xor",         "xor_eq",
        },
        .types = &amp;.{
            "void",     "char",      "char8_t",  "char16_t",
            "char32_t", "wchar_t",   "short",    "int",
            "long",     "float",     "double",   "signed",
            "unsigned", "bool",      "size_t",   "ptrdiff_t",
            "int8_t",   "int16_t",   "int32_t",  "int64_t",
            "uint8_t",  "uint16_t",  "uint32_t", "uint64_t",
            "intptr_t", "uintptr_t",
        },
        .builtin = &amp;.{
            "std",      "override", "final", "concept",
            "continue", "return",   "break",
        },
        .constant = &amp;.{
            "nullptr", "true", "false",
        },
        .preproc = &amp;.{
            "#include",            "#define",     "#undef",   "#ifdef",
            "#ifndef",             "#if",         "#endif",   "#else",
            "#elif",               "#line",       "#error",   "#pragma",
            "#warning",            "__cplusplus", "__FILE__", "__LINE__",
            "__DATE__",            "__TIME__",    "__func__", "__FUNCTION__",
            "__PRETTY_FUNCTION__",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .chars = true,
            .uppercase = true,
            .hex = true,
            .bin = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// python
    .{
        .ft_name = "python",
        .ft_ext = &amp;.{
            "py", "pyw", "pyx", "pxd", "pxi",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"#"},
        .mlcmt = .{ "\"\"\"", "", "\"\"\"" },
        .keywords = &amp;.{
            "and",    "as",      "assert",   "class",
            "def",    "del",     "elif",     "else",
            "except", "finally", "for",      "from",
            "global", "if",      "import",   "in",
            "is",     "lambda",  "nonlocal", "not",
            "or",     "pass",    "raise",    "try",
            "while",  "with",    "yield",    "async",
            "await",
        },
        .types = &amp;.{
            "int",       "float",     "complex", "str",   "bytes",
            "bytearray", "bool",      "list",    "tuple", "dict",
            "set",       "frozenset", "object",  "type",
        },
        .builtin = &amp;.{
            "__debug__", "self",   "cls",
            "continue",  "return", "break",
        },
        .constant = &amp;.{
            "True", "False", "None", "NotImplemented", "Ellipsis",
        },
        .preproc = &amp;.{
            "abs",         "all",          "any",        "ascii",
            "bin",         "bool",         "callable",   "chr",
            "classmethod", "compile",      "delattr",    "dir",
            "divmod",      "enumerate",    "eval",       "exec",
            "filter",      "format",       "getattr",    "globals",
            "hasattr",     "hash",         "help",       "hex",
            "id",          "input",        "isinstance", "issubclass",
            "iter",        "len",          "locals",     "map",
            "max",         "memoryview",   "min",        "next",
            "oct",         "open",         "ord",        "pow",
            "print",       "property",     "range",      "repr",
            "reversed",    "round",        "setattr",    "slice",
            "sorted",      "staticmethod", "sum",        "super",
            "vars",        "zip",          "__import__",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .squotes = true,
            .uppercase = true,
            .hex = true,
            .bin = true,
            .octal = true,
            .uscn = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// lua
    .{
        .ft_name = "lua",
        .ft_ext = &amp;.{
            "lua",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"--"},
        .mlcmt = .{ "--[[", "", "]]" },
        .keywords = &amp;.{
            "and",   "do",       "else",   "elseif", "end",
            "for",   "function", "if",     "in",     "local",
            "not",   "or",       "repeat", "then",   "until",
            "while",
        },
        .types = &amp;.{
            "boolean",  "number", "string", "userdata",
            "function", "thread", "table",
        },
        .builtin = &amp;.{
            "_G",   "_VERSION", "self",
            "goto", "return",   "break",
        },
        .constant = &amp;.{
            "true", "false", "nil",
        },
        .preproc = &amp;.{
            "assert",   "collectgarbage", "dofile",   "error",
            "getfenv",  "getmetatable",   "ipairs",   "load",
            "loadfile", "loadstring",     "next",     "pairs",
            "pcall",    "print",          "rawequal", "rawget",
            "rawlen",   "rawset",         "require",  "select",
            "setfenv",  "setmetatable",   "tonumber", "tostring",
            "type",     "unpack",         "xpcall",   "coroutine",
            "debug",    "io",             "math",     "os",
            "package",  "string",         "table",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .squotes = true,
            .uppercase = true,
            .hex = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// javascript
    .{
        .ft_name = "javascript",
        .ft_ext = &amp;.{
            "js", "jsx", "mjs", "cjs",
        },
        .ft_fntails = &amp;.{},
        .lcmt = &amp;.{"//"},
        .mlcmt = .{ "/*", " *", "*/" },
        .keywords = &amp;.{
            "case",    "catch",   "class",      "const",    "debugger",
            "default", "delete",  "do",         "else",     "export",
            "extends", "finally", "for",        "function", "if",
            "import",  "in",      "instanceof", "let",      "new",
            "super",   "switch",  "this",       "throw",    "try",
            "typeof",  "var",     "void",       "while",    "with",
            "yield",   "async",   "await",      "static",   "get",
            "set",
        },
        .types = &amp;.{
            "boolean", "number",  "bigint",  "string",   "symbol",
            "object",  "Array",   "Object",  "Function", "String",
            "Number",  "Boolean", "Date",    "RegExp",   "Error",
            "Map",     "Set",     "Promise", "Symbol",   "BigInt",
        },
        .builtin = &amp;.{
            "globalThis", "console", "window",   "document",
            "global",     "process", "continue", "return",
            "break",
        },
        .constant = &amp;.{
            "true", "false", "null", "undefined", "NaN", "Infinity",
        },
        .preproc = &amp;.{
            "parseInt",      "parseFloat",         "isNaN",
            "isFinite",      "encodeURI",          "encodeURIComponent",
            "decodeURI",     "decodeURIComponent", "eval",
            "setTimeout",    "setInterval",        "clearTimeout",
            "clearInterval", "JSON",               "Math",
            "console",       "alert",              "confirm",
            "prompt",        "require",            "module",
            "exports",       "__dirname",          "__filename",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .squotes = true,
            .uppercase = true,
            .hex = true,
            .bin = true,
            .octal = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// bash
    .{
        .ft_name = "bash",
        .ft_ext = &amp;.{
            "sh", "bash", "zsh", "fish",
        },
        .ft_fntails = &amp;.{ ".bashrc", ".bash_profile", ".zshrc", ".profile" },
        .lcmt = &amp;.{"#"},
        .mlcmt = null,
        .keywords = &amp;.{
            "if",     "then",     "else",     "elif",    "fi",
            "case",   "esac",     "for",      "while",   "until",
            "do",     "done",     "function", "select",  "time",
            "in",     "break",    "continue", "return",  "exit",
            "local",  "readonly", "declare",  "typeset", "export",
            "unset",  "shift",    "set",      "unalias", "alias",
            "source", "eval",     "exec",     "trap",    "wait",
            "jobs",   "bg",       "fg",       "disown",  "suspend",
            "kill",   "killall",  "nohup",    "logout",
        },
        .types = &amp;.{
            "array", "string", "integer", "associative",
        },
        .builtin = &amp;.{
            "echo",      "printf", "read",    "test",  "cd",
            "pwd",       "pushd",  "popd",    "dirs",  "history",
            "fc",        "hash",   "type",    "which", "command",
            "builtin",   "enable", "help",    "bind",  "complete",
            "compgen",   "caller", "getopts", "let",   "mapfile",
            "readarray", "ulimit", "umask",   "shopt", "times",
        },
        .constant = &amp;.{
            "true", "false",
        },
        .preproc = &amp;.{
            "$0",            "$1",           "$2",              "$3",
            "$4",            "$5",           "$6",              "$7",
            "$8",            "$9",           "$@",              "$*",
            "$#",            "$",            "$!",              "$?",
            "$-",            "$_",           "$HOME",           "$PATH",
            "$PWD",          "$OLDPWD",      "$USER",           "$UID",
            "$SHELL",        "$TERM",        "$LANG",           "$LC_ALL",
            "$TMPDIR",       "$IFS",         "$PS1",            "$PS2",
            "$PS3",          "$PS4",         "$PROMPT_COMMAND", "$BASH",
            "$BASH_VERSION", "$BASHPID",     "$BASH_SUBSHELL",  "$LINENO",
            "$FUNCNAME",     "$BASH_SOURCE", "$BASH_LINENO",    "$SECONDS",
            "$RANDOM",       "$REPLY",       "$OPTARG",         "$OPTIND",
            "$HOSTNAME",     "$HOSTTYPE",    "$MACHTYPE",       "$OSTYPE",
            "$PIPESTATUS",   "$SHELLOPTS",   "$BASHOPTS",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .squotes = true,
            .backticks = true,
            .uppercase = true,
        },
    },

    //////////////////////////////////////////////////////////////////////////
    //// gitconfig
    .{
        .ft_name = "gitconfig",
        .ft_ext = &amp;.{},
        .ft_fntails = &amp;.{ ".gitconfig", ".git/config" },
        .lcmt = &amp;.{ "#", ";" },
        .mlcmt = null,
        .keywords = &amp;.{
            "auto",     "always", "never", "local", "global", "system",
            "worktree",
        },
        .types = &amp;.{
            "core",        "user",       "remote",        "branch",
            "merge",       "push",       "pull",          "fetch",
            "alias",       "color",      "diff",          "log",
            "status",      "commit",     "tag",           "rebase",
            "rerere",      "submodule",  "credential",    "http",
            "https",       "url",        "init",          "clone",
            "gc",          "fsck",       "pack",          "receive",
            "transfer",    "uploadpack", "uploadarchive", "advice",
            "apply",       "blame",      "browser",       "clean",
            "column",      "format",     "grep",          "gui",
            "help",        "i18n",       "imap",          "instaweb",
            "interactive", "mailinfo",   "mailmap",       "man",
            "notes",       "pager",      "pretty",        "protocol",
            "sendemail",   "sequence",   "showbranch",    "web",
        },
        .builtin = &amp;.{
            "HEAD",   "FETCH_HEAD", "ORIG_HEAD", "MERGE_HEAD",
            "master", "main",       "origin",    "upstream",
            "refs",   "heads",      "tags",      "remotes",
        },
        .constant = &amp;.{
            "true", "false", "yes", "no", "on", "off",
        },
        .preproc = &amp;.{
            "name",                           "email",
            "editor",                         "pager",
            "excludesfile",                   "attributesfile",
            "hooksPath",                      "templatedir",
            "gitProxy",                       "sshCommand",
            "askpass",                        "autocrlf",
            "safecrlf",                       "filemode",
            "ignorecase",                     "precomposeUnicode",
            "hideDotFiles",                   "symlinks",
            "bare",                           "worktree",
            "logAllRefUpdates",               "repositoryformatversion",
            "sharedrepository",               "denyCurrentBranch",
            "denyNonFastforwards",            "fsckObjects",
            "transferFsckObjects",            "receivefsckObjects",
            "allowTipSHA1InWant",             "allowReachableSHA1InWant",
            "allowAnySHA1InWant",             "advertiseRefs",
            "allowUnadvertisedObjectRequest", "keepAlive",
            "maxStartups",                    "timeout",
            "uploadpack",                     "uploadarchive",
        },
        .flags = .{
            .numbers = true,
            .strings = true,
            .dquotes = true,
            .squotes = true,
        },
    },
};

const t = @import("types.zig");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-string-functions"><a class="header" href="#new-string-functions">New string functions</a></h1>
<p>We'll complete our <code>string</code> module with a new set of functions that we'll use
for syntax highlighting.</p>
<h3 id="streql"><a class="header" href="#streql">str.eql</a></h3>
<p>We could just call <code>mem.eql(u8, ...)</code> everywhere. It's just a shorthand.
I don't know it's good practice, but we'll call it many times and the meaning
is immediately obvious, so it's ok for me.</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">/// Return `true` if slices have the same content.
pub fn eql(a: []const u8, b: []const u8) bool {
    return mem.eql(u8, a, b);
}
</code></pre>
<h3 id="stristail"><a class="header" href="#stristail">str.isTail</a></h3>
<p>This is used for filetype detection.</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">/// Return `true` if the tail of haystack is exactly `needle`.
pub fn isTail(haystack: []const u8, needle: []const u8) bool {
    const idx = mem.lastIndexOfLinear(u8, haystack, needle);
    return idx != null and idx.? + needle.len == haystack.len;
}
</code></pre>
<h3 id="strgetextension"><a class="header" href="#strgetextension">str.getExtension</a></h3>
<p>Also used for filetype detection.</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">/// Get the extension of a filename.
pub fn getExtension(path: []u8) ?[]u8 {
    const ix = mem.lastIndexOfScalar(u8, path, '.');
    if (ix == null or ix == path.len - 1) {
        return null;
    }
    return path[ix.? + 1 ..];
}
</code></pre>
<h3 id="strisseparator"><a class="header" href="#strisseparator">str.isSeparator</a></h3>
<p>This one is very similar to <code>str.isWord</code>. It's actually the opposite. I only
make it a different function to be able to check whitespace before other
characters, since whitespace is the most common way to separate words, and
should be prioritized when deciding if something is a separator or not.</p>
<p>But I'm not sure it really makes a difference. If it doesn't, this function
should be removed and<br />
<code>!str.isWord()</code> would be used instead.</p>
<div class="code-title">string.zig</div>
<pre><code class="language-zig">/// Return true if character is a separator (not a word character).
pub fn isSeparator(c: u8) bool {
    if (c == ' ' or c == '\t') return true;
    return switch (c) {
        '0'...'9', 'a'...'z', 'A'...'Z', '_' =&gt; false,
        else =&gt; true,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="digression-inline-keyword"><a class="header" href="#digression-inline-keyword">Digression: inline keyword</a></h1>
<h3 id="inline-with-functions"><a class="header" href="#inline-with-functions"><code>inline</code> with functions</a></h3>
<pre><code>The inline calling convention forces a function to be inlined at all call sites.
If the function cannot be inlined, it is a compile-time error.
</code></pre>
<p>This what the creator of the Zig language
<a href="https://ziggit.dev/t/inlining-functions/1341/3">wrote</a>:</p>
<div id="admonition-quote" class="admonition admonish-quote" role="note" aria-labelledby="admonition-quote-title">
<div class="admonition-title">
<div id="admonition-quote-title">
<p>Quote</p>
</div>
<a class="admonition-anchor-link" href="syntax/inline.html#admonition-quote"></a>
</div>
<div>
<p>It’s best to let the compiler decide when to inline a function, except for
these scenarios:</p>
<ul>
<li>You want to change how many stack frames are in the call stack, for
debugging purposes</li>
<li>You want the comptime-ness of the arguments to propagate to the return
value of the function</li>
<li>Performance measurements <em>demand</em> it. Don’t guess!</li>
</ul>
<p>Otherwise you actually end up <em>restricting</em> what the compiler is allowed to do
when you use <code>inline</code> which can harm binary size, compilation speed, and even
runtime performance.</p>
</div>
</div>
<p>So basically he's recommending <em>not</em> to use it unless you have a <em>good</em> and
<em>measurable</em> reason to do so.</p>
<h3 id="other-uses-of-inline"><a class="header" href="#other-uses-of-inline">Other uses of inline</a></h3>
<p>From the <a href="https://ziglang.org/documentation/0.15.1">official language reference</a>:</p>
<ul>
<li><a href="https://ziglang.org/documentation/0.15.1/#inline-fn">inline functions</a></li>
<li><a href="https://ziglang.org/documentation/0.15.1/#inline-while">inline while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.1/#inline-for">inline for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.1/#Inline-Switch-Prongs">inline switch prongs</a></li>
</ul>
<p>Other uses of <code>inline</code> are very different, because they usually allow loops to
be evaluated at compile time. I've never used them, since I never felt the need
for them, so I can't tell you more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filetype-detection"><a class="header" href="#filetype-detection">Filetype detection</a></h1>
<p>We'll write a function named <code>selectSyntax</code> to detect and set the buffer
syntax. This function will be invoked in two places:</p>
<ul>
<li>in <code>openFile()</code>:</li>
</ul>
<div class="code-title">Editor.zig: openFile()</div>
<div class="code-diff-added">
<pre><code class="language-zig">    B.filename = try e.updateString(B.filename, path);
</code></pre>
</div>
<pre><code class="language-zig">    B.syntax = try e.selectSyntax();
</code></pre>
<ul>
<li>in <code>saveFile()</code>, so that we can set a syntax for newly created files, after
we give them a name:</li>
</ul>
<div class="code-title">Editor.zig: saveFile()</div>
<div class="code-diff-added-top">
<pre><code class="language-zig">    B.syntax = try e.selectSyntax();
</code></pre>
</div>
<pre><code class="language-zig">    // determine number of bytes to write, make room for \n characters
    var fsize: usize = B.rows.items.len;
</code></pre>
<h2 id="the-selectsyntax-function"><a class="header" href="#the-selectsyntax-function">The <code>selectSyntax()</code> function</a></h2>
<p>I put this in the "Syntax highlighting" section.</p>
<p>We start by freeing the old syntax, then we try to assign it again.
For now unnamed buffers can't set a syntax, but it will be selected when the
buffer is named and saved.</p>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">/// Return the syntax name for the current file, or null.
fn selectSyntax(e: *Editor) !?[]const u8 {
    var B = &amp;e.buffer;

    // free the old syntax, if any
    t.freeOptional(e.alc, B.syntax);
    B.syntax = null;

    // we might allow setting a syntax even without a filename, actually...
    // but for now it's not possible
    if (B.filename == null) {
        return null;
    }

    // code to come...
}
</code></pre>
<p>We get the extension of the syntax, then we loop over all syntax definitions
and we see if any of them matches for that extension.</p>
<p>If none of the extension matches, we match against the tail of the filename.</p>
<div class="code-title">Editor.zig: selectSyntax()</div>
<pre><code class="language-zig">    const fileExt = str.getExtension(B.filename.?);

    for (&amp;syndefs.Syntaxes) |*syntax| {
        if (fileExt) |extension| {
            for (syntax.ft_ext) |ext| {
                if (str.eql(ext, extension)) {
                    B.syndef = syntax;
                    return try e.alc.dupe(u8, syntax.ft_name);
                }
            }
        }
        for (syntax.ft_fntails) |name| {
            if (str.isTail(B.filename.?, name)) {
                B.syndef = syntax;
                return try e.alc.dupe(u8, syntax.ft_name);
            }
        }
    }
    return null;
</code></pre>
<h3 id="needed-constants-1"><a class="header" href="#needed-constants-1">Needed constants:</a></h3>
<div class="code-title">Editor.zig</div>
<pre><code class="language-zig">const syndefs = @import("syndefs.zig");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doing-the-highlight"><a class="header" href="#doing-the-highlight">Doing the highlight</a></h1>
<p>First, let's add a new option, which controls globally if syntax highlighting
should be done or not:</p>
<div class="code-title">option.zig</div>
<pre><code class="language-zig">/// Enable syntax highlighting
pub var syntax = true;
</code></pre>
<p>In <code>updateHighlight</code>, we'll return early if the buffer has no filetype, or this
option is disabled.</p>
<div class="code-title">Editor.zig: updateHighlight()</div>
<pre><code class="language-zig">    // reset the row highlight to normal
    row.hl = try e.alc.realloc(row.hl, row.render.len);
    @memset(row.hl, .normal);
</code></pre>
<div class="code-diff-added-top">
<pre><code class="language-zig">    if (e.buffer.syntax == null or opt.syntax == false) {
        return;
    }
</code></pre>
</div>
<p>We do the highlight of the whole rendered row. This is certainly not ideal,
because certain files have very long lines, and only a part of it is actually
visible. At the same time, if we restrict parsing to only what we can see, we
will certainly have bad highlight in all those cases where the highlight of
a character depends on what precedes it, or even follows.</p>
<p>We could try to do it anyway and add some safety margin, both on the left and
the right side of the rendered part of the line, so that parsing starts before
<code>coloff</code> and ends after <code>coloff + screen.cols</code>, but it wouldn't be perfect
(think of very long line comments).</p>
<p>We could make it optional, to have a <em>fast highlight mode</em>, but we can't change
options inside the editor.</p>
<p>Doing it properly would need some serious changes, but we'll pass this time.
I said it is a toy editor for reasons, and this isn't the only one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="top-level-symbols"><a class="header" href="#top-level-symbols">Top-level symbols</a></h1>
<p>Before we start the loop that iterates all characters visible on screen, we
define some constants and variables.</p>
<p>The most important one is <code>prev_sep</code>: it controls when we can start to parse
something new. If this variable isn't set correctly where it needs to be,
highlighting of will be likely broken.</p>
<p><code>in_string</code>, which tells us if we're in a string or not, is checked early since
inside strings we should ignore everything else, except escaped characters (for
which we have an <code>escaped</code> variable).</p>
<p>Similarly for <code>in_mlcomment</code>: also in this case we don't parse anything until
we find the sequence that closes the comment.</p>
<pre><code class="language-zig">    //////////////////////////////////////////
    //          Top-level symbols
    //////////////////////////////////////////

    // length of the rendered row
    const rowlen = row.render.len;

    // syntax definition
    const s = e.buffer.syndef.?;

    // line comment leader
    const lc = s.lcmt;

    // multiline comment leaders
    const mlc = s.mlcmt;

    // syntax flags
    const flags = s.flags;

    // character is preceded by a separator
    var prev_sep = true;

    // character is preceded by a backslash
    var escaped = false;

    // character is inside a string or char literal
    var in_string = false;
    var in_char = false;
    var delimiter: u8 = 0;

    // line is in a multiline comment
    var in_mlcomment = ix &gt; 0 and e.buffer.rows.items[ix - 1].ml_comment;

    // all keywords in the syntax definition, subdivided by kinds
    // each kind has its own specific highlight
    const all_syn_keywords = [_]struct {
        kind: []const []const u8, // array with keywords of some kind
        hl: t.Highlight,
    }{
        .{ .kind = s.keywords, .hl = t.Highlight.keyword },
        .{ .kind = s.types,    .hl = t.Highlight.types },
        .{ .kind = s.builtin,  .hl = t.Highlight.builtin },
        .{ .kind = s.constant, .hl = t.Highlight.constant },
        .{ .kind = s.preproc,  .hl = t.Highlight.preproc },
    };
</code></pre>
<h2 id="the-top-level-loop"><a class="header" href="#the-top-level-loop">The top-level loop</a></h2>
<p>We'll have multiple nested loops, so we will use labels to break to an outer
loop. The top-level loop has the <code>toplevel</code> label.</p>
<p>We'll use labels for all loops, and all <code>break</code> and <code>continue</code> statements. This
way it should be clearer from which loop we're breaking.</p>
<p>At the bottom of the top-level loop we'll increase the row index and set the
<em>critical</em> <code>prev_sep</code> variable.</p>
<p>First thing we do is to skip whitespaces, which are also a valid separator.</p>
<pre><code class="language-zig">    var i: usize = 0;
    toplevel: while (i &lt; rowlen) {
        if (asc.isWhitespace(row.render[i])) { // skip whitespaces
            prev_sep = true;
            i += 1;
            continue :toplevel;
        }

        // rest of parsing goes here...

        prev_sep = str.isSeparator(row.render[i]);
        i += 1;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-line-comments"><a class="header" href="#multi-line-comments">Multi-line comments</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="syntax/update3.html#admonition-note"></a>
</div>
<div>
<p>Remember that we had, when defining constants and variables:</p>
<pre class="code-block-small"><code class="language-zig">// line is in a multiline comment
var in_mlcomment = ix > 0 and e.buffer.rows.items[ix - 1].ml_comment;
</code></pre>
</div>
</div>
<h4 id="we-have-ml-comments"><a class="header" href="#we-have-ml-comments">we have ML comments...</a></h4>
<p>Our <code>mlcmt</code> field is an optional field, so we must check if it's <code>null</code>.
If not <code>null</code>, it's a <code>[3]u8</code> array with start marker, middle marker and
end marker.</p>
<pre><code class="language-zig">        // ML comments
        if (mlc != null and mlc.?.len &gt; 0 and !in_string) {
            const mc = mlc.?;
</code></pre>
<h4 id="we-are-in-a-ml-comment"><a class="header" href="#we-are-in-a-ml-comment">we are in a ML comment...</a></h4>
<p>... this we can know because <code>in_mlcomment</code> is true if the previous row's
<code>ml_comment</code> field is true.</p>
<p>In this case we paint the character as ML comment, and keep looking for the end
marker.</p>
<pre><code class="language-zig">            if (in_mlcomment) {
                const len = mc[2].len;
                row.hl[i] = t.Highlight.mlcomment;
</code></pre>
<h4 id="we-do-find-the-end-marker"><a class="header" href="#we-do-find-the-end-marker">we do find the end marker...</a></h4>
<p>... then <code>in_mlcomment</code> becomes false. After the marker, normal parsing resumes
in this row.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="syntax/update3.html#admonition-note-1"></a>
</div>
<div>
<p>We don't <em>break</em> out of the top-level loop, we <em>continue</em> it, because unlike
line comments, multi-line ones can end in the same line where they started.</p>
</div>
</div>
<pre><code class="language-zig">                if (i + len &lt;= rowlen and str.eql(row.render[i .. i + len], mc[2])) { // END
                    @memset(row.hl[i .. i + len], t.Highlight.mlcomment);
                    i += len;
                    in_mlcomment = false;
                    prev_sep = true;
                    continue :toplevel;
                }
</code></pre>
<h4 id="we-dont-find-the-end-marker"><a class="header" href="#we-dont-find-the-end-marker">we don't find the end marker...</a></h4>
<p>... then <code>in_mlcomment</code> keeps being true also for this line. We keep painting
everything as ML comment.</p>
<pre><code class="language-zig">                else {
                    i += 1;
                    continue :toplevel;
                }
            }
</code></pre>
<h4 id="we-arent-in-a-ml-comment-yet"><a class="header" href="#we-arent-in-a-ml-comment-yet">we aren't in a ML comment yet...</a></h4>
<p>... and we find the start marker. <code>in_mlcomment</code> becomes true. From then
onwards, characters are painted as ML comment.</p>
<pre><code class="language-zig">            else {
                const len = mc[0].len;

                if (i + len &lt;= rowlen and str.eql(row.render[i .. i + len], mc[0])) { // START
                    @memset(row.hl[i .. i + len], t.Highlight.mlcomment);
                    i += len;
                    in_mlcomment = true;
                    continue :toplevel;
                }
            }
        }
</code></pre>
<p>Following row will have <code>in_mlcomment</code> set to false.</p>
<h3 id="a-change-in-comment-state-triggers-a-chain-update"><a class="header" href="#a-change-in-comment-state-triggers-a-chain-update">A change in comment state triggers a chain update</a></h3>
<p>Normally we only update the row that has changed, but for multi-line patterns,
we must update following rows too, otherwise their highlight would stay the
same.</p>
<p>We must keep updating following rows, until the value of <code>in_mlcomment</code> matches
the value of <code>row.ml_comment</code>: only in this case we know that the row wasn't
affected by the multi-line pattern. Only then we can stop the chain of row
updates.</p>
<p>This is done at the very bottom of the <code>updateHighlight</code> function. Add it now,
so that you can have a clearer picture.</p>
<div class="code-title">Editor.zig: bottom of updateHighlight()</div>
<pre><code class="language-zig">    // If a multiline comment state has changed (either a comment started, or
    // a previous one has been closed) we must update following the row, which
    // will in turn update others, until all rows affected by the comment are
    // updated.
    const mlc_state_changed = row.ml_comment != in_mlcomment;
    row.ml_comment = in_mlcomment;
    if (mlc_state_changed and ix + 1 &lt; e.buffer.rows.items.len) {
        try e.updateHighlight(ix + 1);
    }
</code></pre>
<p>If you still didn't get it, imagine 10 rows, no ML comments. Their
<code>row.ml_comment</code> is false.</p>
<div class="numbered-table-no-bar">
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>1.</td><td>if ML comment starts at line 2, <code>in_mlcomment</code> becomes true</td></tr>
<tr><td>2.</td><td><code>in_mlcomment</code> is different from <code>row.ml_comment</code> and it triggers the chain update</td></tr>
<tr><td>3.</td><td>following row has <code>in_mlcomment</code> set to true, because it's equal to <code>row.ml_comment</code> of previous row</td></tr>
<tr><td>4.</td><td>it's different from its own <code>row.ml_comment</code>, chain update continues</td></tr>
<tr><td>5.</td><td>all following lines become commented this way, all their <code>row.ml_comment</code> becomes true</td></tr>
<tr><td>6.</td><td>now you insert the end marker at line 4</td></tr>
<tr><td>7.</td><td>you trigger another chain update, which reverses the state of the lines that follow</td></tr>
</tbody></table>
</div></div>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="syntax/update3.html#admonition-note-2"></a>
</div>
<div>
<p>This chain update is probably inefficient, since after the rows that follow are
updated, they will be updated again when it's their turn in <code>drawRows()</code> to be
updated. We could use a Buffer field to track how many lines could skip the
update, because they've been updated this way. We're not doing it, though.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="line-comments"><a class="header" href="#line-comments">Line comments</a></h2>
<p>For line comments we just check we aren't in a string or in a multiline
comment, and we look for the comment leader. If found, the rest of the line is
a comment, no need to continue parsing this line.</p>
<div class="code-title">Editor.zig: inside updateHighlight() top-level loop</div>
<pre><code class="language-zig">        // single-line comment
        if (lc.len &gt; 0 and !in_string and !in_mlcomment) {
            for (lc) |ldr| {
                if (i + ldr.len &lt;= rowlen and str.eql(row.render[i .. i + ldr.len], ldr)) {
                    @memset(row.hl[i..], t.Highlight.comment);
                    break :toplevel;
                }
            }
        }
</code></pre>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Highlighting of strings is controlled by <code>Syntax.flags.strings</code>, but that's not
enough. Syntaxes can support double quoted strings, single quoted strings,
backticks as strings or <em>char</em> literals, or more often a combination of them.</p>
<p><code>in_string</code> and <code>in_char</code> differ because the highlight is different (<em>string</em>
vs <em>number</em>). Moreover different delimiters must be handled independently: if
a double quote is found and a string starts, a single quote after that is still
part of the string. Same is true for double quotes after single quotes.</p>
<p>Whatever the delimiter and the string type, an escaped character is an escaped
character, and it gets the <code>.escape</code> highlight, together with the escaping
backslash.</p>
<p>If the start of a string or a <em>char</em> literal is found, <code>delimiter</code> is set to
the character, and the appropriate highlight is set until <code>delimiter</code> is found
again.</p>
<p>Multi-line strings aren't supported.</p>
<div class="code-title">Editor.zig: inside updateHighlight() top-level loop</div>
<pre><code class="language-zig">        if (flags.strings) {
            if (in_string or in_char) {
                if (escaped or row.render[i] == '\\') {
                    escaped = !escaped;
                    row.hl[i] = t.Highlight.escape;
                }
                else {
                    row.hl[i] = if (in_char) t.Highlight.number else t.Highlight.string;
                    if (row.render[i] == delimiter) {
                        in_string = false;
                        in_char = false;
                    }
                }
                i += 1;
                continue :toplevel;
            }
            else if (flags.dquotes and row.render[i] == '"'
                     or flags.squotes and row.render[i] == '\''
                     or flags.backticks and row.render[i] == '`') {
                in_string = true;
                delimiter = row.render[i];
                row.hl[i] = t.Highlight.string;
                i += 1;
                continue :toplevel;
            }
            else if (flags.chars and row.render[i] == '\'') {
                in_char = true;
                delimiter = row.render[i];
                row.hl[i] = t.Highlight.number;
                i += 1;
                continue :toplevel;
            }
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<p>Parsing numbers depends on syntax flags: different filetypes support different
number formats. The formats we support are:</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>format</th><th>flag</th></tr></thead><tbody>
<tr><td>integers</td><td><code>N</code></td><td>numbers</td></tr>
<tr><td>floats</td><td><code>N.N([eE]N)?</code></td><td>numbers</td></tr>
<tr><td>hex</td><td><code>0[xX]N</code></td><td>hex</td></tr>
<tr><td>octal</td><td><code>0[oO]N</code></td><td>octal</td></tr>
<tr><td>binary</td><td><code>0[bB]N</code></td><td>bin</td></tr>
</tbody></table>
</div>
<p>Integers and floats are always parsed if <code>flags.numbers</code> is true.</p>
<p>First we check if it's some special number notation (hex, octal binary). If
true, we set the appropriate boolean variable and advance the index by
2 characters.</p>
<div class="code-title">Editor.zig: inside updateHighlight() top-level loop</div>
<pre><code class="language-zig">        // numbers
        if (flags.numbers and prev_sep) {
            var prev_digit = false;
            var is_float = false;
            var has_exp = false;
            var is_hex = false;
            var is_bin = false;
            var is_octal = false;
            var NaN = false;

            const begin = i;

            // hex, binary, octal notations
            if (i + 1 &lt; rowlen) {
                if (row.render[i] == '0') {
                    switch (row.render[i + 1]) {
                        'x', 'X' =&gt; if (flags.hex) {
                            is_hex = true;
                            i += 2;
                        },
                        'b', 'B' =&gt; if (flags.bin) {
                            is_bin = true;
                            i += 2;
                        },
                        'o', 'O' =&gt; if (flags.octal) {
                            is_octal = true;
                            i += 2;
                        },
                        else =&gt; {},
                    }
                }
            }
</code></pre>
<p>Then we parse the actual number. What counts as a digit depends on the type
that has been detected. If it's not a special notation, we only accept digits
and a dot.</p>
<p>The variable <code>prev_digit</code> is true if the previous character was a valid digit
for the type. This variable must be true at the end of the parsing, or this
simply isn't a number.</p>
<p>If <code>flags.uscn</code> is true, we also accept underscores as separator. They are part
of the number, but they aren't digits themselves, so if they aren't followed by
a digit, it won't be a number.</p>
<p>For the dot, it's similar: it requires to be followed by a digit, otherwise
it's a simple separator. Not only that, but there can be only one dot in the
number. Finding a dot the first time sets <code>is_float</code>, finding it twice means
it's not a number.</p>
<p>Same goes for <code>e/E</code> (exponent): they must be followed by digits, and may not
appear more than once. If it's a hex digit, though, <code>e/E</code> are digits, not
exponents.</p>
<div class="code-title">Editor.zig: flags.numbers</div>
<pre><code class="language-zig">            // accept consecutive digits, or a dot followed by a number
            digits: while (true) : (i += 1) {
                if (i == rowlen) break :digits;

                switch (row.render[i]) {
                    '0'...'1' =&gt; prev_digit = true,

                    // invalid for binary numbers
                    '2'...'7' =&gt; {
                        if (!is_bin) {
                            prev_digit = true;
                        }
                        else {
                            prev_digit = false;
                            break :digits;
                        }
                    },

                    // invalid for binary and octal numbers
                    '8'...'9' =&gt; {
                        if (!is_bin and !is_octal) {
                            prev_digit = true;
                        }
                        else {
                            prev_digit = false;
                            break :digits;
                        }
                    },

                    // underscores as delimiters in numeric literals
                    '_' =&gt; {
                        if (prev_digit and flags.uscn) {
                            prev_digit = false;
                        }
                        else {
                            break :digits;
                        }
                    },

                    // could be an exponent, or a hex digit
                    'e', 'E' =&gt; {
                        if (is_float and !has_exp) {
                            has_exp = true;
                            prev_digit = false;
                        }
                        else if (is_hex) {
                            prev_digit = true;
                        }
                        else {
                            break :digits;
                        }
                    },

                    // hex digits
                    'a'...'d', 'f', 'A'...'D', 'F' =&gt; {
                        if (is_hex) prev_digit = true else break :digits;
                    },

                    // floating point
                    '.' =&gt; {
                        prev_sep = true;
                        prev_digit = false;
                        if (!is_float and !is_hex and !is_bin) {
                            is_float = true;
                        }
                        else {
                            break :digits;
                        }
                    },

                    else =&gt; break :digits,
                }
            }
</code></pre>
<p>After the loop ends, because a character has been found that is not valid for
the type of number, we check if it's actually a number:</p>
<ul>
<li>last character must be a valid digit</li>
<li>it must be followed by either a separator or end of line</li>
</ul>
<p>We must also set the very important <code>prev_sep</code> variable, which controls whether
the following characters may be parsed as new tokens, or as part of the
previous one, or not at all. In this case, since we only have keywords left to
parse, if this is <code>false</code> it will effectively end the parsing of the line.</p>
<p>If end of line has been reached we stop.</p>
<div class="code-title">Editor.zig: flags.numbers</div>
<pre><code class="language-zig">            // previous separator could be invalid if any character was
            // processed
            prev_sep = i == begin or str.isSeparator(row.render[i - 1]);

            // no matter the type of number, last character should be a digit
            if (!prev_digit) {
                NaN = true;
            }
            // after our number comes something that isn't a separator
            else if (i != rowlen and !str.isSeparator(row.render[i])) {
                NaN = true;
            }
            if (!NaN) {
                for (begin..i) |idx| {
                    row.hl[idx] = t.Highlight.number;
                }
            }
        }
        if (i == rowlen) break :toplevel;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="keywords"><a class="header" href="#keywords">Keywords</a></h2>
<p>Remember the constant we set before the top-level loop started:</p>
<pre><code class="language-zig">    // all keywords in the syntax definition, subdivided by kinds
    // each kind has its own specific highlight
    const all_syn_keywords = [_]struct {
        kind: []const []const u8, // array with keywords of some kind
        hl: t.Highlight,
    }{
        .{ .kind = s.keywords, .hl = t.Highlight.keyword },
        .{ .kind = s.types,    .hl = t.Highlight.types },
        .{ .kind = s.builtin,  .hl = t.Highlight.builtin },
        .{ .kind = s.constant, .hl = t.Highlight.constant },
        .{ .kind = s.preproc,  .hl = t.Highlight.preproc },
    };
</code></pre>
<p>Now we iterate this array. Each element of this array is a set of keywords
(<code>[]const []const u8</code>), together with the highlight which they will use.</p>
<p>We loop each of these sets of keyword: if we find that what follows the current
position is the keyword, we set the highlight and advance the position by the
keyword length.</p>
<div class="code-title">Editor.zig: inside updateHighlight() top-level loop</div>
<pre><code class="language-zig">        // keywords
        if (prev_sep) {
            kwloop: for (all_syn_keywords) |keywords| {
                for (keywords.kind) |kw| {
                    const kwend = i + kw.len; // index where keyword would end

                    // separator or end of row after keyword
                    if ((kwend &lt; rowlen and str.isSeparator(row.render[kwend]))
                        or kwend == rowlen)
                    {
                        if (str.eql(row.render[i..kwend], kw)) {
                            @memset(row.hl[i..kwend], keywords.hl);
                            i += kw.len;
                            break :kwloop;
                        }
                    }
                }
            }
</code></pre>
<h2 id="uppercase-words"><a class="header" href="#uppercase-words">Uppercase words</a></h2>
<p>Similar process, but we don't loop any array, we just check if there's
a sequence of uppercase characters or underscores.</p>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="syntax/update6.html#admonition-important"></a>
</div>
<div>
<p>We must reset the <code>prev_sep</code> variable before continuing, or the loop will hang.</p>
</div>
</div>
<div class="code-title">Editor.zig: inside updateHighlight() continuing block</div>
<pre><code class="language-zig">            if (flags.uppercase) {
                var upper = false;
                const begin = i;
                upp: while (i &lt; rowlen and !str.isSeparator(row.render[i])) {
                    if (!asc.isUpper(row.render[i]) and row.render[i] != '_') {
                        upper = false;
                        break :upp;
                    }
                    upper = true;
                    i += 1;
                }
                if (upper and i - begin &gt; 1) {
                    @memset(row.hl[begin..i], t.Highlight.uppercase);
                }
            }
            prev_sep = false;
            continue :toplevel;
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>I hope you found it interesting and/or useful.</p>
<p>Credits and thanks:</p>
<ul>
<li>Andrew Kelley for creating the Zig programming language</li>
<li>Users of the Ziggit forum for answering questions</li>
<li>Especially user <a href="https://ziggit.dev/u/vulpesx">@vulpesx</a> for advices on making the code more idiomatic for Zig</li>
<li>Paige Ruten, the writer of the <a href="https://viewsourcecode.org/snaptoken/kilo/">original booklet</a></li>
<li>Salvatore Sanfilippo, the author of the original <a href="https://github.com/antirez/kilo">kilo editor</a></li>
</ul>
<p>With that I don't mean the code is perfect, as I wrote in the introduction, but
I did my best.</p>
<p>If you find mistakes, oversights or bad/wrong explanations of language
concepts/features, please post an issue.</p>
<p>Thanks for reading.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
